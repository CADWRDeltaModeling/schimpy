
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>schimpy.lsc2 &#8212; schimpy 1.2.1+1.ge1e6d39.dirty documentation</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo6.png" border="0" alt="Bay-Delta SELFE Tools"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.lsc2</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for schimpy.lsc2</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot; Methods for generating local sigma coordinates</span>
<span class="sd">    These routines are meant to be called a pair. First,</span>
<span class="sd">    default_num_layers is called to obtain the recommended number of layers for</span>
<span class="sd">    each node based on depth. Then, gen_sigma is called to generate</span>
<span class="sd">    the actual local sigma values at each level (nlevels = nlayers+1).</span>

<span class="sd">    Note that in this script eta is the &quot;reference&quot; free surface at which the mesh</span>
<span class="sd">    is conditioned, which can be a global scalar or array of local nodal values.</span>
<span class="sd">    Using a medium-higher value (2-4 depending on typical flood levels) usually</span>
<span class="sd">    does&#39;t hurt the final product in low water. The example() shows how to visualize a mesh</span>
<span class="sd">    generated on one ref water surface on another surface.</span>

<span class="sd">    The major user parameters are already set at their defaults. It is mildly</span>
<span class="sd">    important to realize that the S coordinate parameters have the same qualitative</span>
<span class="sd">    interpretation, but that the S system is really just used as a heuristic and</span>
<span class="sd">    everything is manipulated locally.</span>

<span class="sd">    Besides theta (refinement to the surface) the mostly likely item to manipulate</span>
<span class="sd">    will be minlayer and maxlayer. These can be supplied locally (if these are</span>
<span class="sd">    given as arrays) or globally (if provided as scalars).</span>


<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">schimpy.laplace_smooth_data</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">showlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c1">#,419,28778,28923,237892,237893,232311]</span>
<span class="n">showlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7942</span><span class="p">,</span> <span class="mi">7967</span><span class="p">,</span> <span class="mi">7968</span><span class="p">,</span> <span class="mi">7969</span><span class="p">,</span> <span class="mi">7972</span><span class="p">]</span>
<span class="n">showlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">67</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">76</span><span class="p">]</span>
<span class="n">showlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">29914</span><span class="p">,</span> <span class="mi">29915</span><span class="p">,</span><span class="mi">30094</span><span class="p">,</span><span class="mi">30774</span><span class="p">]</span>
<span class="n">showlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16948</span><span class="p">,</span><span class="mi">16949</span><span class="p">,</span><span class="mi">207525</span><span class="p">,</span><span class="mi">207526</span><span class="p">]</span>
<span class="n">showlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">245201</span><span class="p">]</span>

<div class="viewcode-block" id="szcoord"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.szcoord">[docs]</a><span class="k">def</span> <span class="nf">szcoord</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">hc</span><span class="p">):</span>
    <span class="n">thetaterm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">thetavec</span> <span class="o">=</span> <span class="n">theta</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">thetavec</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">thetavec</span><span class="p">)</span>\
        <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">thetavec</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">-</span> <span class="n">thetaterm</span><span class="p">)</span> <span class="o">/</span> <span class="n">thetaterm</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">hc</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">hc</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">z</span></div>




<div class="viewcode-block" id="default_num_layers0"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.default_num_layers0">[docs]</a><span class="k">def</span> <span class="nf">default_num_layers0</span><span class="p">(</span><span class="n">total_ref_depth</span><span class="p">,</span> <span class="n">minlayer</span><span class="p">,</span> <span class="n">maxlayer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">minlayer</span><span class="p">,</span> <span class="n">total_ref_depth</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)),</span> <span class="n">maxlayer</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="CubicLSC2MeshFunction"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.CubicLSC2MeshFunction">[docs]</a><span class="k">class</span> <span class="nc">CubicLSC2MeshFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#self.params = np.array([0.6,0.066,0.002,1e-5])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.055</span><span class="p">,</span><span class="mf">0.002</span><span class="p">,</span><span class="mf">1e-5</span><span class="p">])</span>

<div class="viewcode-block" id="CubicLSC2MeshFunction.density"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.CubicLSC2MeshFunction.density">[docs]</a>    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">tlev</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span><span class="o">**</span><span class="mf">3.</span><span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CubicLSC2MeshFunction.depth"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.CubicLSC2MeshFunction.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">tlev</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span><span class="o">**</span><span class="mf">4.</span><span class="o">/</span><span class="mf">4.</span><span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span><span class="o">**</span><span class="mf">3.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span><span class="o">**</span><span class="mf">2.</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">tlev</span>
        <span class="k">return</span> <span class="n">d</span></div></div>



<div class="viewcode-block" id="BilinearMeshDensity"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.BilinearMeshDensity">[docs]</a><span class="k">class</span> <span class="nc">BilinearMeshDensity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#self.params = np.array([0.6,0.066,0.002,1e-5])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.012</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1e-5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.09</span><span class="p">,</span><span class="o">-</span><span class="mf">8.5e-5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.07</span><span class="p">,</span><span class="o">-</span><span class="mf">3.e-5</span><span class="p">])</span>


<div class="viewcode-block" id="BilinearMeshDensity.density"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.BilinearMeshDensity.density">[docs]</a>    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="n">h</span></div>

<div class="viewcode-block" id="BilinearMeshDensity.depth"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.BilinearMeshDensity.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
        <span class="n">opnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> 
        <span class="n">retval</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">opnd</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">retval</span></div></div>




<div class="viewcode-block" id="default_num_layers"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.default_num_layers">[docs]</a><span class="k">def</span> <span class="nf">default_num_layers</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">minlayer</span><span class="p">,</span> <span class="n">maxlayer</span><span class="p">,</span><span class="n">dz_target</span><span class="p">,</span><span class="n">meshfun</span><span class="p">,</span><span class="n">maxlev</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the number of layers that, according to meshfun, gives a depth matching eta + h0</span>
<span class="sd">        In the (likely) case of inexact fit) the lower bound n- of the number of layers</span>
<span class="sd">        not yet outfitted for variation in x&quot;&quot;&quot;</span>
    <span class="n">totaldepth</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">+</span> <span class="n">h0</span>
    <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="n">maxlev</span><span class="p">))</span>
    <span class="n">levdepths</span> <span class="o">=</span> <span class="n">meshfun</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">levs</span><span class="p">,</span><span class="n">totaldepth</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># todo: redo with ndindex</span>
    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">totaldepth</span><span class="p">)</span>
    <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
        <span class="c1">#hi_ndx is the index that is equal or greater</span>
        <span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">levdepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,:],</span><span class="n">totaldepth</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum reference depth: </span><span class="si">{}</span><span class="s2"> Unrestricted max layer: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">totaldepth</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)))</span>
    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
        <span class="n">minlayer</span><span class="p">,</span> <span class="p">(</span><span class="n">nlayer</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)),</span> <span class="n">maxlayer</span><span class="p">)</span> <span class="c1">#.astype(&#39;f&#39;)    </span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# small minlayer = </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">minlayer</span><span class="o">&lt;=</span><span class="mf">1.</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Any small number layers: </span><span class="si">%s</span><span class="s2"> at index </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">nlayer</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)))</span>   
    <span class="k">return</span> <span class="n">nlayer</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="example3"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.example3">[docs]</a><span class="k">def</span> <span class="nf">example3</span><span class="p">():</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">h0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">20.</span><span class="p">,</span><span class="mf">28.</span><span class="p">])</span>
    <span class="n">minlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">maxlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">])</span>
    <span class="n">meshfun</span> <span class="o">=</span> <span class="n">BilinearMeshDensity</span><span class="p">()</span>
    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">default_num_layers</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">minlayer</span><span class="p">,</span><span class="n">maxlayer</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">meshfun</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span></div>


<div class="viewcode-block" id="example2"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.example2">[docs]</a><span class="k">def</span> <span class="nf">example2</span><span class="p">():</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">h0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.58</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">4.5</span><span class="p">,</span><span class="mf">107.0</span><span class="p">,</span><span class="mf">120.</span><span class="p">])</span>
    <span class="n">minlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
    <span class="n">maxlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">38</span><span class="p">,</span><span class="mi">38</span><span class="p">])</span>
    <span class="n">meshfun</span> <span class="o">=</span> <span class="n">BilinearMeshDensity</span><span class="p">()</span>
    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">default_num_layers</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">minlayer</span><span class="p">,</span><span class="n">maxlayer</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">meshfun</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">gen_sigma</span><span class="p">(</span><span class="n">nlayer</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">meshfun</span><span class="p">)</span></div>


<div class="viewcode-block" id="mesh_function_depths"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.mesh_function_depths">[docs]</a><span class="k">def</span> <span class="nf">mesh_function_depths</span><span class="p">(</span><span class="n">nlayer</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">meshfun</span><span class="p">):</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Entering mesh_functino_depths&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inode=</span><span class="si">{}</span><span class="s2"> depth=</span><span class="si">{}</span><span class="s2"> nlayer=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>
    
    
    
    <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span>
    <span class="n">globalmaxlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span>
    <span class="n">nlevel</span> <span class="o">=</span> <span class="n">nlayer</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">globalmaxlevel</span> <span class="o">=</span> <span class="n">globalmaxlayer</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">meshfundepths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">npoint</span><span class="p">,</span> <span class="n">globalmaxlevel</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1"># sigmadepths is the uniform mesh implied by applying the layer thickness over the depth</span>
    <span class="n">sigmadepths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">npoint</span><span class="p">,</span> <span class="n">globalmaxlevel</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">hsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>



    <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">globalmaxlevel</span><span class="p">)</span> <span class="c1"># The plus two is to protect against situations when all nlayer == 0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoint</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
        <span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,:]</span><span class="o">=</span><span class="n">meshfun</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">levs</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">x</span><span class="p">)</span>

    <span class="n">dz1</span> <span class="o">=</span> <span class="n">meshfundepths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># height (dz) of top layer</span>



    <span class="n">hnv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dz1</span><span class="p">)</span>         <span class="c1">#</span>
    <span class="n">hnv1</span> <span class="o">=</span> <span class="n">hnv</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dh_meshfun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dz1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
        <span class="c1"># hnv is depth given by # vertical layers and mesh function</span>
        <span class="c1"># hnv1 is the depth of the level above</span>
        <span class="c1"># In this version, the vanilla case is that these straddle depth</span>

        <span class="n">hnv</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hnv1</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">excess_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-</span> <span class="n">hnv1</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
        <span class="n">dh_meshfun</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">hnv</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-</span> <span class="n">hnv1</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>

        <span class="c1"># rule out cases where the bed is at above the lowest meshfun (which will become</span>
        <span class="c1"># hybrid with sigma or sigma)</span>
        <span class="c1"># rule out the exact case where the bed ifind out if lowest level falls below bottom (eliminating exact fit case)</span>
        <span class="c1"># and if it does check if it is a sliver</span>
        <span class="n">sliver</span> <span class="o">=</span> <span class="mf">0.025</span>

        <span class="k">if</span> <span class="n">excess_depth</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">excess_depth</span> <span class="o">&lt;</span> <span class="n">sliver</span><span class="o">*</span><span class="n">dh_meshfun</span><span class="p">[</span><span class="n">inode</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>    <span class="c1"># todo is this the right plae for nlayer check?</span>

                <span class="c1"># sliver below bed that needs to be absorbed into layer above</span>
                <span class="c1"># reduce nlevel and nlayer, readjust hnv. Mesh will be stretched later. hnv1[inode] is now invalidv</span>
                <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WATCH inode=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
                <span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
                <span class="n">hnv</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">excess_depth</span> <span class="o">&lt;</span> <span class="n">dh_meshfun</span><span class="p">[</span><span class="n">inode</span><span class="p">]:</span>
                <span class="c1"># it is sufficiently big, set it to bed height</span>
                <span class="c1">#todo: could these be asserts?</span>
                <span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
                <span class="n">hnv</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">excess_depth</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">dh_meshfun</span><span class="p">[</span><span class="n">inode</span><span class="p">]:</span>
                    <span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">dh_meshfun</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
            <span class="c1">#else:</span>
            <span class="c1">#    #print &quot;excess at {}&quot;.format(inode)</span>

        <span class="n">sigmadepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">dz1</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
        <span class="n">hsig</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">=</span><span class="n">sigmadepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sigmadepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">hsig</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SHOWLIST&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inode=</span><span class="si">{}</span><span class="s2"> depth=</span><span class="si">{}</span><span class="s2"> nlevel=</span><span class="si">{}</span><span class="s2"> nlayer=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">meshfundepths</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
    


    <span class="c1"># hsig is the depth of a uniform sigma grid</span>
    <span class="c1"># given the specificed num layers and layer thickness of the top layer</span>
    <span class="c1"># from the mesh function. If the depth is less this, a pure sigma grid will be used</span>
    <span class="c1"># todo: single layer is a special case that I thought would be taken care of by using &lt;= not =</span>
    <span class="c1"># but the special case seems to require spelling out</span>
    <span class="n">is_sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;=</span> <span class="n">hsig</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">nlayer</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>


    <span class="c1"># is_expand means that the depth is greater than the depth of the mesh function evaluated at the bottom level.</span>
    <span class="c1"># This will often be true ... it implies some stretching, which may be a lot or a little</span>
    <span class="c1"># For now (pre-stretch) use the coordinates as given by mesh function (min/max doesn&#39;t affect)</span>
    <span class="n">is_expand</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">hnv</span>
        
    <span class="c1"># for hsig &lt;= h &lt; htrans the levels given by meshfun don&#39;t quite fit in the (shallower) water column, </span>
    <span class="c1"># so transition to sigma coordinates with weight gamma</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;gamma stuff&quot;</span><span class="p">)</span>
    <span class="c1">#for inode in showlist:</span>
    <span class="c1">#    print(depth[inode])</span>
    <span class="c1">#    print(hsig[inode])</span>
    <span class="c1">#    print(hnv[inode])</span>
    <span class="c1">#    print(meshfundepths[inode,:])</span>
    
    <span class="n">safe_divisor</span> <span class="o">=</span> <span class="n">hnv</span> <span class="o">-</span> <span class="n">hsig</span>
    <span class="n">safe_divisor</span><span class="p">[</span><span class="n">hnv</span> <span class="o">==</span> <span class="n">hsig</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="c1"># todo is this really safe?</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.</span><span class="p">,(</span><span class="n">depth</span> <span class="o">-</span> <span class="n">hsig</span><span class="p">)</span><span class="o">/</span><span class="n">safe_divisor</span> <span class="p">)</span> <span class="p">)</span>  <span class="c1"># One value per node</span>
    <span class="n">htrans</span>  <span class="o">=</span> <span class="p">(</span><span class="n">meshfundepths</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">gamma</span> <span class="o">+</span> <span class="n">sigmadepths</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">gamma</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">dh_meshfun</span> <span class="o">=</span> <span class="n">dh_meshfun</span><span class="o">*</span><span class="n">gamma</span> <span class="o">+</span> <span class="n">dz1</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span>


    <span class="c1"># now evaluate any stretching to be done</span>
    <span class="c1"># the stretching factor starts out at zero at the surface and linearly increases to the full amount</span>
    <span class="c1"># at the lowest level. In other words, the stretching gets stretched</span>
    <span class="n">stretch</span> <span class="o">=</span> <span class="n">depth</span><span class="o">/</span><span class="n">hnv</span>
    <span class="n">expandfac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">globalmaxlevel</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_expand</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">expandfac</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="mf">4.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">stretch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
            <span class="n">expandfac</span><span class="p">[</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">expandfac</span><span class="p">[</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">htrans</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">expandfac</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span><span class="o">*</span><span class="n">htrans</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="n">dh_meshfun</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">stretch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># todo: this is new because it gives some behavior for sigma. This is reasonable for positive depth but</span>
        <span class="c1"># a bit funny for negative. The real issue of course is that the bed is above the reference</span>
        <span class="k">if</span> <span class="n">is_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">htrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">htrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;{{{{{{</span><span class="si">{}</span><span class="s2">}}}}}}&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">i=</span><span class="si">{}</span><span class="s2"> depth =</span><span class="si">{}</span><span class="s2"> gamma=</span><span class="si">{}</span><span class="s2"> nlayer=</span><span class="si">{}</span><span class="s2"> hvn=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nlayer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">hnv</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">htrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;meshfundepths:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">meshfundepths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sigmadepths&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">sigmadepths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">htrans</span><span class="p">,</span><span class="n">is_sigma</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">dh_meshfun</span></div>


<div class="viewcode-block" id="lowest_layer_height"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.lowest_layer_height">[docs]</a><span class="k">def</span> <span class="nf">lowest_layer_height</span><span class="p">(</span><span class="n">htrans</span><span class="p">,</span><span class="n">nlevel</span><span class="p">,</span><span class="n">klev</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">npoint</span> <span class="o">=</span> <span class="n">htrans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;npoint: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">npoint</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">htrans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">llh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipoint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
        <span class="n">bigindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nlevel</span><span class="p">[</span><span class="n">ipoint</span><span class="p">]</span><span class="o">-</span><span class="n">klev</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">llh</span><span class="p">[</span><span class="n">ipoint</span><span class="p">]</span> <span class="o">=</span> <span class="n">htrans</span><span class="p">[</span><span class="n">ipoint</span><span class="p">,</span><span class="n">bigindex</span><span class="p">]</span> <span class="o">-</span> <span class="n">htrans</span><span class="p">[</span><span class="n">ipoint</span><span class="p">,</span><span class="n">bigindex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1">#todo: experieent necessitated because htrans can go negative when bed is above reference</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">llh</span><span class="p">)</span></div>




<div class="viewcode-block" id="label_components"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.label_components">[docs]</a><span class="k">def</span> <span class="nf">label_components</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">thresh</span><span class="p">,</span><span class="n">exclude</span><span class="p">):</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nlayer</span><span class="p">))</span>

    <span class="n">labels</span><span class="p">[</span><span class="n">exclude</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">current_label</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
    <span class="n">qualified</span> <span class="o">=</span> <span class="p">(</span><span class="n">nlayer</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">labels</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">qualified</span><span class="p">):</span>
        <span class="n">current_label</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1"># pick first seed that qualifies and that isn&#39;t labeled yet</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">qualified</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span> 
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">nlayer</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_label</span>
                <span class="n">cc</span><span class="p">[</span><span class="n">current_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_neighbor_nodes</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
        <span class="n">qualified</span> <span class="o">=</span> <span class="p">(</span><span class="n">nlayer</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">labels</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of components: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">cc</span></div>



<div class="viewcode-block" id="process_orphans2"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.process_orphans2">[docs]</a><span class="k">def</span> <span class="nf">process_orphans2</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">hcor</span><span class="p">):</span>
    <span class="n">norphan</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">smallest_nlayer</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># don&#39;t check for orphans smaller than this # layers</span>
    <span class="n">smallest_component_size</span> <span class="o">=</span> <span class="mi">16</span>   <span class="c1"># size of component considered orphan</span>

    <span class="k">for</span> <span class="n">ilay</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlayer</span><span class="p">,</span><span class="n">smallest_nlayer</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">exclude</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nlayer</span><span class="o">&lt;=</span><span class="n">ilay</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;orphans </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ilay</span><span class="p">))</span>
        <span class="c1"># find connected components that have this many or fewer layers</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">label_components</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">ilay</span><span class="p">,</span><span class="n">exclude</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
        <span class="c1">#print sizes</span>
        <span class="n">use_labels</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sizes</span> <span class="o">&lt;</span> <span class="n">smallest_component_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iuse</span> <span class="ow">in</span> <span class="n">use_labels</span><span class="p">:</span>
            <span class="n">cuse</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="n">iuse</span><span class="p">]</span>
            <span class="n">norphan</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cuse</span><span class="p">)</span>
            <span class="c1">#print &quot;cuse&quot;</span>
            <span class="c1">#print cuse</span>
            <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">cuse</span><span class="p">:</span>
                <span class="c1">#print &quot;inode&quot;</span>
                <span class="c1">#print inode</span>
                <span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]:]</span><span class="o">=</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ilay=</span><span class="si">{}</span><span class="s2"> norphan = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ilay</span><span class="p">,</span><span class="n">norphan</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nlayer</span><span class="p">,</span><span class="n">hcor</span></div>



<div class="viewcode-block" id="process_orphans"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.process_orphans">[docs]</a><span class="k">def</span> <span class="nf">process_orphans</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">hcor</span><span class="p">):</span>
    <span class="n">norphan</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span>
    <span class="k">for</span> <span class="n">ndx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">nds</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_neighbor_nodes</span><span class="p">(</span><span class="n">ndx</span><span class="p">)</span>
        <span class="n">nlayer_node</span> <span class="o">=</span> <span class="n">nlayer</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span>
        <span class="n">max_nlayer_neighbor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nlayer</span><span class="p">[</span><span class="n">nds</span><span class="p">])</span>

        <span class="n">is_orphan</span> <span class="o">=</span> <span class="n">max_nlayer_neighbor</span> <span class="o">&lt;</span> <span class="n">nlayer_node</span> <span class="c1">#No connectivity,</span>
        <span class="k">if</span> <span class="n">is_orphan</span><span class="p">:</span>
            <span class="n">nlayer</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_nlayer_neighbor</span>
            <span class="n">hcor</span><span class="p">[</span><span class="n">ndx</span><span class="p">,</span><span class="n">nlayer</span><span class="p">[</span><span class="n">ndx</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span>
            <span class="n">norphan</span><span class="o">+=</span><span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# orphans = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">norphan</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nlayer</span></div>


<div class="viewcode-block" id="smooth_bed"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.smooth_bed">[docs]</a><span class="k">def</span> <span class="nf">smooth_bed</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">hcor</span><span class="p">,</span><span class="n">nlevel</span><span class="p">,</span><span class="n">speed</span><span class="p">):</span>

    <span class="n">nsmoothlev</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlevel</span><span class="p">)</span>
    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">nlevel</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">zsmooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoint</span><span class="p">,</span><span class="n">nsmoothlev</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">zsmooth</span><span class="p">[:,</span><span class="n">nsmoothlev</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">h</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="o">-</span><span class="n">h</span>


    <span class="c1">#hlow = lowest_layer_height(hcor,nlevel,0)</span>
    <span class="c1"># speed = np.absolute(hlow)</span>
    <span class="c1"># with nsmoothlay = 1 used vel=speed*.7,kappa=.75,dt=0.05,iter_total=20</span>
    <span class="c1"># this includes experimental smoothing based on neighbors in the base layer and/or current layer depending on whether</span>
    <span class="c1"># the number of layers is less in the neighbor. If reverting, eliminate nlayer and use laplace_wismooth_with_vel3</span>
    <span class="c1">#new_layer = laplace_smooth_with_vel3(mesh,nlayer,old_layer,vel=speed*.6,kappa=0.75,dt=0.05,iter_total=20)</span>
    <span class="n">new_layer</span> <span class="o">=</span> <span class="n">laplace_smooth_with_vel3</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">old_layer</span><span class="p">,</span><span class="n">vel</span><span class="o">=</span><span class="n">speed</span><span class="o">*.</span><span class="mi">2</span><span class="p">,</span><span class="n">kappa</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">iter_total</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="c1">#latest_layer = np.where(new_layer&gt;old_layer, new_layer, old_layer)</span>

    <span class="c1"># todo: At the moment this script not equipped to change the # of layers.</span>
    <span class="c1"># As a result we want to keep the bottom layer off the bed by limiting its shrinkage</span>
    <span class="n">latest_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">old_layer</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="n">new_layer</span><span class="p">)</span>
    <span class="n">zsmooth</span><span class="p">[:,</span><span class="n">nsmoothlev</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">latest_layer</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="n">latest_layer</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;zsmoothsave.txt&quot;</span><span class="p">,</span><span class="n">zsmooth</span><span class="p">)</span>
    <span class="c1"># Now generate new mesh depths using the smoothed elevations as a pseudo-bed</span>
    <span class="c1"># and one fewer layers</span>
    <span class="c1"># Mind that the outcome from the previous step is in z coordinates, not depth</span>
    <span class="c1"># but the depth function works based on depth from reference eta</span>
    <span class="n">hsmooth</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">-</span> <span class="n">zsmooth</span>
    <span class="n">pseudo_bed_depth</span> <span class="o">=</span> <span class="n">hsmooth</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pseudo_bed_depth</span></div>



<div class="viewcode-block" id="gen_sigma"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.gen_sigma">[docs]</a><span class="k">def</span> <span class="nf">gen_sigma</span><span class="p">(</span><span class="n">nlayer</span><span class="p">,</span> <span class="n">minlayer</span><span class="p">,</span> <span class="n">maxlayer</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">meshfun</span><span class="p">,</span> <span class="n">nsmoothlay</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot; Generate local sigma coordinates based on # layers, reference surface and depth</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nlayer: ndarray</span>
<span class="sd">            Veector of size np (number of nodes) giving desired # layers for each node</span>
<span class="sd">            in the mesh</span>

<span class="sd">        eta: ndarray or float</span>
<span class="sd">            reference water level heights at each node at which generation is to occur.</span>

<span class="sd">        h: ndarray</span>
<span class="sd">            unperturbed depth for each node in the mesh</span>

<span class="sd">        mesh : float</span>
<span class="sd">            maximum theta to use in S calculations. This is interpreted the same</span>
<span class="sd">            as a standard S grid theta although it will be varied according to depth</span>

<span class="sd">        meshfun: float</span>
<span class="sd">            S coordinate parameter b</span>
<span class="sd">            </span>
<span class="sd">        nsmoothlay: how many layers to smooth on the bottom</span>

<span class="sd">        hc: float</span>
<span class="sd">            S coordinate parameter hc (do not alter)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">depth</span><span class="o">=</span><span class="n">eta</span><span class="o">+</span><span class="n">h</span>
    <span class="c1"># Have to do this first because nlayer may be modified</span>
    <span class="n">hcor</span><span class="p">,</span><span class="n">is_sigma</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">dh_meshfun</span> <span class="o">=</span> <span class="n">mesh_function_depths</span><span class="p">(</span><span class="n">nlayer</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">mesh</span><span class="p">,</span><span class="n">meshfun</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;first hcor&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
    
    
    <span class="c1">#def layer_depths(nlayer, depth, mesh, meshfun):</span>

    <span class="n">do_smooth</span> <span class="o">=</span> <span class="n">nsmoothlay</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">SIGMA_NEG</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9999.</span>

    <span class="c1"># This is the first pass at generating the zcor using the mesh function</span>
    <span class="c1"># If we aren&#39;t smoothing this is the z part of the final mesh</span>

    <span class="n">smooth_to_archive</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span>
    <span class="n">globalmaxlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nlayer</span><span class="p">)</span>
    <span class="n">nlevel</span> <span class="o">=</span> <span class="n">nlayer</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">globalmaxlevel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nlevel</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Global maxlevel before smooth: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">globalmaxlevel</span><span class="p">))</span>
    


    <span class="n">nsmoothlev</span> <span class="o">=</span> <span class="n">nsmoothlay</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1">#do_smooth = True</span>
    <span class="k">if</span> <span class="n">do_smooth</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;******</span><span class="se">\n\n\n</span><span class="s2">Smoothing&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hcor dims&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">nlevel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">nlayer</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
   
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i=</span><span class="si">{}</span><span class="s2"> nlevel = </span><span class="si">{}</span><span class="s2">, depth=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;firlst&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        
        
        <span class="n">zsmooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npoint</span><span class="p">,</span><span class="n">nsmoothlev</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">zsmooth</span><span class="p">[:,</span><span class="n">nsmoothlev</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">h</span>
        <span class="n">old_layer</span> <span class="o">=</span> <span class="o">-</span><span class="n">h</span>

        <span class="k">if</span> <span class="n">smooth_to_archive</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsmoothlay</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;layer iteration: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">hlow</span> <span class="o">=</span> <span class="n">lowest_layer_height</span><span class="p">(</span><span class="n">hcor</span><span class="p">,</span><span class="n">nlevel</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> 
                <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">hlow</span><span class="p">)</span>
                <span class="c1"># with nsmoothlay = 1 used vel=speed*.7,kappa=.75,dt=0.05,iter_total=20</span>
                <span class="c1"># this includes experimental smoothing based on neighbors in the base layer and/or current layer depending on whether</span>
                <span class="c1"># the number of layers is less in the neighbor. If reverting, eliminate nlayer and use laplace_wismooth_with_vel3</span>
                <span class="c1">#new_layer = laplace_smooth_with_vel3(mesh,nlayer,old_layer,vel=speed*.6,kappa=0.75,dt=0.05,iter_total=20)</span>
                <span class="n">new_layer</span> <span class="o">=</span> <span class="n">laplace_smooth_with_vel3</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">old_layer</span><span class="p">,</span><span class="n">vel</span><span class="o">=</span><span class="n">speed</span><span class="o">*.</span><span class="mi">6</span><span class="p">,</span><span class="n">kappa</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">iter_total</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                <span class="c1">#latest_layer = np.where(new_layer&gt;old_layer, new_layer, old_layer)</span>

                <span class="c1"># todo: At the moment this script not equipped to change the # of layers.</span>
                <span class="c1"># As a result we want to keep the bottom layer off the bed by limiting its shrinkage</span>
                <span class="n">latest_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">old_layer</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="n">new_layer</span><span class="p">)</span>
                <span class="n">zsmooth</span><span class="p">[:,</span><span class="n">nsmoothlev</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">latest_layer</span>
                <span class="n">old_layer</span> <span class="o">=</span> <span class="n">latest_layer</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;zsmoothsave.txt&quot;</span><span class="p">,</span><span class="n">zsmooth</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zsmooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;zsmoothsave.txt&quot;</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Linking&quot;</span><span class="p">)</span>
        <span class="c1"># Now generate new mesh depths using the smoothed elevations as a pseudo-bed</span>
        <span class="c1"># and one fewer layers</span>
        <span class="c1"># Mind that the outcome from the previous step is in z coordinates, not depth</span>
        <span class="c1"># but the depth function works based on depth from reference eta</span>
        <span class="n">hsmooth</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">-</span> <span class="n">zsmooth</span>
        <span class="n">pseudo_bed_depth</span> <span class="o">=</span> <span class="n">hsmooth</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>



        <span class="c1"># todo from here down is experimental. The next couple lines setup computation of # levels revised</span>
        <span class="c1"># after that, nlevel was replaced by nlevel2.</span>
        <span class="n">dztarget</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nlayer</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
        <span class="n">xdummy</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">eta_dummy</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c1"># todo: is this good enough? Did it because we already have the eta part of the depth in pseudo_bed_depth</span>

        <span class="n">nlayer2</span> <span class="o">=</span> <span class="n">default_num_layers</span><span class="p">(</span><span class="n">xdummy</span><span class="p">,</span><span class="n">eta_dummy</span><span class="p">,</span> <span class="n">pseudo_bed_depth</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">minlayer</span><span class="o">-</span><span class="n">nsmoothlay</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">maxlayer</span><span class="o">-</span><span class="n">nsmoothlay</span><span class="p">),</span> <span class="n">dztarget</span><span class="p">,</span><span class="n">meshfun</span><span class="p">)</span>

        <span class="c1"># the code later recognizes the minimum of 1 enforced above and below is artificial the globalmaxlayer stuff prevents</span>
        <span class="c1"># going past bound ... something that came up in a small test problem</span>
        <span class="n">nlayer2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">nlayer2</span><span class="p">,</span> <span class="n">globalmaxlayer</span><span class="o">-</span><span class="n">nsmoothlay</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;yo&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">nlayer2</span><span class="p">)</span>
         
        <span class="c1"># this is a flag needed used later to signal to indicate not enough layers to absorb nsmoothlay into the total</span>
        <span class="c1"># this is the last opportunity to calculate it based on the original number of layers</span>
        <span class="c1"># this is an all-or-nothing approach that does not try to eek out every opportunity to use the smoothed layers.</span>
        <span class="c1"># for instance, if nsmoothlay = 2 and there are 2 original layers we could conceivably use the lowest smoothed layer</span>
        <span class="c1"># and then ignore the upper one in order to match the reference</span>
        <span class="n">few4smooth</span><span class="o">=</span><span class="p">(</span><span class="n">nlayer</span> <span class="o">&lt;=</span> <span class="n">nsmoothlay</span><span class="p">)</span>

        <span class="c1">#nlayer2 = np.where(nlayer &gt; nsmoothlay,nlayer2,nlayer)  # right generalization ? will need to test</span>
        <span class="c1">#nlayer2 = nlayer_default</span>
        <span class="c1">#nlayer = tabu_numlayer(depth,mesh.edges,nlayer_default,minlayer,maxlayer)</span>



        <span class="c1">#</span>
        <span class="c1"># nlayer-nsmoothlay</span>

        <span class="n">hcor2</span><span class="p">,</span><span class="n">is_sigma2</span><span class="p">,</span><span class="n">nlayer2</span> <span class="o">=</span> <span class="n">mesh_function_depths</span><span class="p">(</span><span class="n">nlayer2</span><span class="p">,</span><span class="n">pseudo_bed_depth</span><span class="p">,</span><span class="n">mesh</span><span class="p">,</span><span class="n">meshfun</span><span class="p">)</span>

        <span class="n">nlevel2</span> <span class="o">=</span> <span class="n">nlayer2</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">nlevel3</span> <span class="o">=</span> <span class="n">nlevel2</span><span class="o">+</span><span class="n">nsmoothlay</span>
        <span class="n">nlayer3</span> <span class="o">=</span> <span class="n">nlayer2</span><span class="o">+</span><span class="n">nsmoothlay</span>


        <span class="c1"># This is simplified from before when it was possible for the smoothing process</span>
        <span class="c1"># to reduce the # levels. At the moment the interface is assumed to be the top</span>
        <span class="c1"># smoothed level</span>
        <span class="c1">#bndlevel = np.maximum(0,nlevel2 - nsmoothlay - 1).astype(&#39;i&#39;)</span>
        <span class="n">bndlevel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nlevel2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nbnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">bndlevel</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="n">nsmoothlay</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>


        <span class="c1"># Blend the region around the interface between the upper part done with the mesh</span>
        <span class="c1"># function and the lower part done with the smoothing</span>
        <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
            <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel2</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">blev</span> <span class="o">=</span> <span class="n">bndlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xxxxxxxxxxx</span><span class="se">\n</span><span class="s2">i=</span><span class="si">{}</span><span class="s2"> nlevels = </span><span class="si">{}</span><span class="s2"> nlevel2 = </span><span class="si">{}</span><span class="s2"> nlevel3 = </span><span class="si">{}</span><span class="se">\n</span><span class="s2"> blev = </span><span class="si">{}</span><span class="s2"> depth = </span><span class="si">{}</span><span class="s2"> pseudo_be_depth=</span><span class="si">{}</span><span class="s2"> is_sigma=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">blev</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">pseudo_bed_depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">is_sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>            
            <span class="k">if</span> <span class="n">blev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;to be joined&quot;</span><span class="p">)</span>                    
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">i=</span><span class="si">{}</span><span class="s2"> nlevels = </span><span class="si">{}</span><span class="s2"> nlevel2 = </span><span class="si">{}</span><span class="s2"> nlevel3 = </span><span class="si">{}</span><span class="se">\n</span><span class="s2"> blev = </span><span class="si">{}</span><span class="s2"> depth = </span><span class="si">{}</span><span class="s2"> pseudo_be_depth=</span><span class="si">{}</span><span class="s2"> is_sigma=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">blev</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">pseudo_bed_depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">is_sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">hcor2</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">hsmooth</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
            <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">blev</span><span class="p">]</span> <span class="o">=</span> <span class="n">hcor2</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">blev</span><span class="p">]</span>
            <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="p">:</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]]</span> <span class="o">=</span> <span class="n">hsmooth</span><span class="p">[</span><span class="n">inode</span><span class="p">,:]</span>   <span class="c1"># nlevel3 is the adjusted number</span>
            <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># copy to lower levels</span>
            
            <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;** hcor after merge before bound inode = </span><span class="si">{}</span><span class="s2">** &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &amp;*&amp;*&quot;</span><span class="p">)</span>
            <span class="c1">#zcor[inode,0:(bndlevel[inode]+1)] = np.linspace(eta,zcor[inode,bndlevel[inode]],bndlevel[inode]+1)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">blev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nbnd</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
               <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.4</span><span class="o">*</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">blev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nbnd</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.7</span><span class="o">*</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">blev</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>              
            
            <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;final hcor inode=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># seems like if # smoothing is zero these are not provided?</span>
        <span class="n">nlevel2</span><span class="o">=</span><span class="n">nlevel</span>
        <span class="n">nlevel3</span><span class="o">=</span><span class="n">nlevel</span>

    <span class="n">smooth_bed_clip</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">smooth_bed_clip</span><span class="p">:</span>
        <span class="n">smoothed_bed</span> <span class="o">=</span> <span class="n">smooth_bed</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">hcor</span><span class="p">,</span><span class="n">nlevel</span><span class="p">,</span><span class="n">dh_meshfun</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,(</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">smoothed_bed</span><span class="p">[</span><span class="n">inode</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&gt;</span> <span class="mi">111900</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&lt;</span> <span class="mi">112000</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inode = </span><span class="si">{}</span><span class="s2">, nlevel=</span><span class="si">{}</span><span class="s2"> smoothed = </span><span class="si">{}</span><span class="s2">  hcor=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">smoothed_bed</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>  <span class="c1"># todo: should this be nan?</span>


    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Procesing orphans&quot;</span><span class="p">)</span>
    <span class="c1">#nlayer = process_orphans(mesh,nlayer,depth,hcor)</span>
    <span class="n">oldnlayer</span> <span class="o">=</span> <span class="n">nlayer</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">nlayer</span><span class="p">,</span><span class="n">hcor</span> <span class="o">=</span> <span class="n">process_orphans2</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">nlayer</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">hcor</span><span class="p">)</span>
    <span class="c1">#plt.hist(oldnlayer-nlayer)</span>
    <span class="c1">#plt.show()</span>


    <span class="n">nlevel3</span> <span class="o">=</span> <span class="n">nlayer</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">nlevel</span> <span class="o">=</span> <span class="n">nlayer</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Convert to sigma&quot;</span><span class="p">)</span>


    <span class="c1"># Convert to sigma and replace</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcor</span> <span class="o">/</span> <span class="n">depth</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sigma</span><span class="p">[</span><span class="n">sigma</span><span class="o">==-</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; (*(*(*())))&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inode=</span><span class="si">{}</span><span class="s2"> depth=</span><span class="si">{}</span><span class="s2"> nlayer=</span><span class="si">{}</span><span class="s2"> nlevel=</span><span class="si">{}</span><span class="s2"> nlevel3=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">depth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlayer</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>

    <span class="k">if</span> <span class="n">nsmoothlay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
            <span class="c1"># when is_sigma changes this is conservative for monotonicity</span>
            <span class="c1"># first, assume that the smoothed layers are OK and just do sigma down to the top of the smoothing</span>
            <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span> <span class="ow">or</span> <span class="n">inode</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;deciding if sigma for i=</span><span class="si">{}</span><span class="s2"> is_sigma= </span><span class="si">{}</span><span class="s2"> is_sigma2=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">is_sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">is_sigma2</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>
            
            <span class="k">if</span> <span class="n">is_sigma2</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="ow">or</span> <span class="n">is_sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">]:</span>
                <span class="n">nnonbndlev</span> <span class="o">=</span> <span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Experimental stuff inode=</span><span class="si">{}</span><span class="s2"> nonbndlev=</span><span class="si">{}</span><span class="s2"> nlevel=</span><span class="si">{}</span><span class="s2"> nlevel2=</span><span class="si">{}</span><span class="s2"> nlevel3=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">inode</span><span class="p">,</span><span class="n">nnonbndlev</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
                <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nnonbndlev</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nnonbndlev</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">nnonbndlev</span><span class="p">)</span> 
                
                
                <span class="c1"># the above step may have left some very thin sigma layers above some very wide smoothing layers</span>
                <span class="c1"># sigmartio is the ratio of the sigma layer width to the top smoothed layer, unless the smoothing went above the</span>
                <span class="c1"># reference ratio (which is indirectly indicated by sigmas&lt;0) and in this case it is just 0. as a signal</span>
                <span class="n">sigmaratio</span> <span class="o">=</span>  <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span> <span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nnonbndlev</span><span class="p">]</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nnonbndlev</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># another flagged issue is the possibility that sigma values are negative, which wouldd have happened because</span>
                <span class="c1"># hsmooth was negative</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nnonbndlev</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
                    <span class="n">sigmaratio</span> <span class="o">=</span> <span class="n">SIGMA_NEG</span>


                <span class="c1"># abandon the shole matching/merge idea and do sigma from scratch</span>
                <span class="c1"># hardwired threshold</span>
                <span class="n">ACCEPT_RATIO</span><span class="o">=</span><span class="mf">0.2</span>
                <span class="n">nlev</span> <span class="o">=</span> <span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="k">if</span> <span class="n">few4smooth</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="k">else</span> <span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
                <span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlev</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sigmaratio</span> <span class="o">&lt;</span> <span class="n">ACCEPT_RATIO</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sigmaratio</span><span class="p">)</span> <span class="ow">or</span> <span class="n">few4smooth</span><span class="p">[</span><span class="n">inode</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">inode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">**</span><span class="se">\n</span><span class="s2">sigma not accepted i=</span><span class="si">{}</span><span class="s2"> sigmaratio=</span><span class="si">{}</span><span class="s2"> nlev=</span><span class="si">{}</span><span class="s2"> few4smooth=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">sigmaratio</span><span class="p">,</span><span class="n">nlev</span><span class="p">,</span><span class="n">few4smooth</span><span class="p">[</span><span class="n">inode</span><span class="p">]))</span>                  
                    <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlev</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">nlev</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="c1">#print &quot;\n**\nsigma IS accepted i={} sigmaratio={} nlev={} few4smooth={}&quot;.format(inode,sigmaratio,nlev,few4smooth[inode])</span>

                <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">showlist</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;\msigmaratio stuff: inode=</span><span class="si">{}</span><span class="s2"> sigmaratio=</span><span class="si">{}</span><span class="s2"> nlevel=</span><span class="si">{}</span><span class="s2"> nlevel2=</span><span class="si">{}</span><span class="s2"> nlevel3=</span><span class="si">{}</span><span class="s2"> few4smooth=</span><span class="si">{}</span><span class="s2"> nnonbndlev=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">inode</span><span class="p">,</span><span class="n">sigmaratio</span><span class="p">,</span><span class="n">nlevel</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel2</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">few4smooth</span><span class="p">[</span><span class="n">inode</span><span class="p">],</span><span class="n">nnonbndlev</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,:])</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;***</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlev</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
            <span class="n">nlev</span> <span class="o">=</span> <span class="n">nlevel3</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">]:</span>
                <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nlev</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">nlev</span><span class="p">)</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="n">nlev</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># todo: these are rules to abandon smoothing altogether and go with even sigma everywhere</span>
    <span class="c1"># the first one says to do it if the number of layers does not exceed the number of smoothing layers</span>
    <span class="c1"># the second says do it if depth of the upper levels isn&#39;t too fine compared to the  enough and that rule is very</span>
    <span class="c1"># ad hoc and hardwired</span>


    <span class="c1">#for inode in range(npoint):</span>
    <span class="c1">#    # when is_sigma changes this is conservative for monotonicity</span>
    <span class="c1">#    if is_sigma[inode] or is_sigma2[inode] or nlevel2[inode] == 2:</span>
    <span class="c1">#        #print nlevel2[inode]</span>
    <span class="c1">#        sigma[inode, 0:nlevel[inode]] = np.linspace(0., 1., nlevel[inode])</span>
    <span class="c1">#    sigma[inode,nlevel[inode]:maxlevel] = np.nan</span>
 
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Testing monotonicity&quot;</span><span class="p">)</span>
    <span class="n">nonmon</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">nonmon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonmon</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nonmon</span><span class="p">))):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">nonmon</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Node </span><span class="si">{}</span><span class="s2"> is not monotonic in sigma&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;depth=</span><span class="si">{}</span><span class="s2"> nlevel0=</span><span class="si">{}</span><span class="s2"> nlevel=</span><span class="si">{}</span><span class="s2"> nlevel2=</span><span class="si">{}</span><span class="s2"> nlevel3=</span><span class="si">{}</span><span class="s2"> is_sigma=</span><span class="si">{}</span><span class="s2"> is_sigma2=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">nlevel0</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                         <span class="n">nlevel</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">nlevel2</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">nlevel3</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">is_sigma</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">is_sigma2</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">ii</span><span class="p">,:])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">hcor</span><span class="p">[</span><span class="n">ii</span><span class="p">,:])</span>


    <span class="nb">print</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">,:])</span>
    <span class="c1">#print sigma[0:7,0:9]</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="o">-</span><span class="n">sigma</span>
    <span class="n">nlayer3</span> <span class="o">=</span> <span class="n">nlevel3</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">sigma</span><span class="p">,</span><span class="n">nlayer3</span></div>






<div class="viewcode-block" id="flip_sigma"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.flip_sigma">[docs]</a><span class="k">def</span> <span class="nf">flip_sigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Flip the ordering of non-nan sigma values.</span>

<span class="sd">        The output of get_sigma starts from 0.0, but sigma in vgrid.in from -0.1.</span>
<span class="sd">        So it needs to be flipped for further use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma: numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            New sigma array that has flipped ordering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">flip_no_nan</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">length_no_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">length_no_nan</span><span class="p">:</span> <span class="n">length_no_nan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[:</span><span class="n">length_no_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[:</span><span class="n">length_no_nan</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">row</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">flip_no_nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span></div>

<div class="viewcode-block" id="plot_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.plot_mesh">[docs]</a><span class="k">def</span> <span class="nf">plot_mesh</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">zcor</span><span class="p">,</span><span class="n">startvis</span><span class="p">,</span><span class="n">stopvis</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">nlevel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">zcor</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">nlevel</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">nquad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">nlayer</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">nlayer</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">nprism</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nlayer</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">nlayer</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ntri</span> <span class="o">=</span> <span class="n">nprism</span> <span class="o">-</span> <span class="n">nquad</span>
    <span class="n">nel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nquad</span><span class="p">)</span>
    <span class="n">maxlevel</span> <span class="o">=</span> <span class="n">zcor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlevel</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlevel</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">startvis</span><span class="p">:</span><span class="n">stopvis</span><span class="p">],</span><span class="n">zcor</span><span class="p">[</span><span class="n">startvis</span><span class="p">:</span><span class="n">stopvis</span><span class="p">,</span><span class="n">i</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startvis</span><span class="p">,</span><span class="n">stopvis</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ilo</span> <span class="o">=</span> <span class="n">el</span>
        <span class="n">ihi</span> <span class="o">=</span> <span class="n">el</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="n">nquad</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>
        <span class="n">npris</span> <span class="o">=</span> <span class="n">nprism</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nq</span> <span class="o">==</span> <span class="n">npris</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># print &quot;%s %s&quot; % (nlevel[el],nlevel[el+1])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">npris</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">zlo</span> <span class="o">=</span> <span class="n">zcor</span><span class="p">[</span><span class="n">ilo</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">nlayer</span><span class="p">[</span><span class="n">ilo</span><span class="p">])]</span>
            <span class="n">zhi</span> <span class="o">=</span> <span class="n">zcor</span><span class="p">[</span><span class="n">ihi</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">nlayer</span><span class="p">[</span><span class="n">ihi</span><span class="p">])]</span>
            <span class="c1"># print &quot;%s %s %s&quot;  % (k,nlayer[ilo],nlayer[ihi])</span>
            <span class="c1"># print &quot;%s %s %s %s&quot; % (x[ilo],x[ihi],zlo,zhi)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">ilo</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">ihi</span><span class="p">]),</span> <span class="p">(</span><span class="n">zlo</span><span class="p">,</span> <span class="n">zhi</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">startvis</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">stopvis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="sigma_z"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.sigma_z">[docs]</a><span class="k">def</span> <span class="nf">sigma_z</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">npoint</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Eta must be a float or numpy array&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="mf">0.</span> <span class="o">+</span> <span class="n">eta</span>
    <span class="n">eta_arr</span> <span class="o">=</span> <span class="n">eta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">eta_arr</span> <span class="o">+</span> <span class="n">h</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">zcor</span> <span class="o">=</span> <span class="n">eta_arr</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">zcor</span><span class="p">[</span><span class="n">depth</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">zcor</span></div>


<div class="viewcode-block" id="z_sigma"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.z_sigma">[docs]</a><span class="k">def</span> <span class="nf">z_sigma</span><span class="p">(</span><span class="n">zcor</span><span class="p">):</span>
    <span class="n">surf</span> <span class="o">=</span> <span class="n">zcor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">zcor</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">zcor</span> <span class="o">-</span> <span class="n">surf</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">/</span><span class="n">depth</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">frac</span></div>



<div class="viewcode-block" id="example"><a class="viewcode-back" href="../../schimpy.html#schimpy.lsc2.example">[docs]</a><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>

    <span class="c1"># Several example csv files are provided&quot;</span>
    <span class="n">exfile</span> <span class="o">=</span> <span class="s2">&quot;test/testdata/transect2a.csv&quot;</span>
    <span class="n">exfile</span> <span class="o">=</span> <span class="s2">&quot;test/testdata/ex5.csv&quot;</span>
    <span class="n">transect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">exfile</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">transect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>      <span class="c1"># x positions for xsect. These have no analog in 3D</span>
    <span class="n">h0</span> <span class="o">=</span> <span class="o">-</span><span class="n">transect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>     <span class="c1"># nominal depth, as in hgrid.gr3</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h0</span><span class="p">)</span>

    <span class="n">eta</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># Reference height at which assessed. Aim on the high side</span>
    <span class="n">minlayer</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">maxlayer</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">maxlayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">maxlayer</span>
    <span class="n">maxlevel</span> <span class="o">=</span> <span class="n">maxlayer</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">+</span> <span class="n">h0</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">hc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">nlayer</span> <span class="o">=</span> <span class="n">default_num_layers</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">minlayer</span><span class="p">,</span> <span class="n">maxlayer</span><span class="p">)</span>
    <span class="c1">#nlayer = gaussian_filter1d(nlayer,sigma=3)</span>
    <span class="c1">#nlayer = gaussian_filter1d(nlayer,sigma=3)</span>

    <span class="n">sigma</span> <span class="o">=</span> <span class="n">gen_sigma</span><span class="p">(</span><span class="n">nlayer</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">hc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">zcor0</span> <span class="o">=</span> <span class="n">sigma_z</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">zcor0</span><span class="p">)</span>

    <span class="n">eta1</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">zcor1</span> <span class="o">=</span> <span class="n">sigma_z</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">eta1</span><span class="p">,</span> <span class="n">h0</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plot_mesh</span><span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">zcor0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
    <span class="n">plot_mesh</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">zcor1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
    <span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">h0</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">h0</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">example2</span><span class="p">()</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.lsc2</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, California Department of Water Resources.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>