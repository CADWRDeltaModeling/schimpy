
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>schimpy.schism_mesh &#8212; schimpy 1.3.6+7.g9f86f0f.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo6.png" border="0" alt="Bay-Delta SELFE Tools"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.schism_mesh</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for schimpy.schism_mesh</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; 3D Version of schism_mesh</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.triquadmesh</span> <span class="kn">import</span> <span class="n">TriQuadMesh</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="p">,</span> <span class="n">EdgeType</span>
<span class="kn">from</span> <span class="nn">.schism_vertical_mesh</span> <span class="kn">import</span> <span class="n">read_vmesh</span>
<span class="kn">import</span> <span class="nn">osgeo.ogr</span>
<span class="kn">import</span> <span class="nn">osgeo.osr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PolyCollection</span><span class="p">,</span> <span class="n">PatchCollection</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">patches</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiLineString</span>
<span class="kn">import</span> <span class="nn">rtree.index</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SchismMesh&#39;</span><span class="p">,</span> <span class="s1">&#39;BoundaryType&#39;</span><span class="p">,</span> <span class="s1">&#39;read_mesh&#39;</span><span class="p">,</span> <span class="s1">&#39;write_mesh&#39;</span><span class="p">,]</span>


<span class="k">def</span> <span class="nf">find_intersection</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate an intersection point from two line segments</span>
<span class="sd">        defined by two end points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> \
          <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">det</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>  <span class="c1"># parallel</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> \
        <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> \
        <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> \
        <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> \
        <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> \
        <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> \
        <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="o">/</span> <span class="n">det</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">intersection</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">intersection</span>
    <span class="n">sign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">intersection</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">intersection</span>
    <span class="n">sign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sign1</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">sign2</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">intersection</span>


<span class="k">class</span> <span class="nc">SchismBoundary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A class describing an individual boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">btype</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_btype</span> <span class="o">=</span> <span class="n">btype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="n">comment</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">btype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Boundary type.</span>

<span class="sd">            :getter: Get the type of the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_btype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A sequence of node indexes in the boundary.</span>

<span class="sd">            :getter: Get the sequence of nodes in the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>

    <span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total number of nodes in the boundary.</span>

<span class="sd">            Return</span>
<span class="sd">            ------</span>
<span class="sd">            integer</span>
<span class="sd">                the total number of nodes in the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a comment or name of the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span>

    <span class="nd">@comment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set a comment or name of the boundary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="n">value</span>


<div class="viewcode-block" id="SchismMesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh">[docs]</a><span class="k">class</span> <span class="nc">SchismMesh</span><span class="p">(</span><span class="n">TriQuadMesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Memory model of 3D SCHISM mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SchismMesh</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vmesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_areas</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merged_mesh</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmesh</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An array of the boundary information</span>

<span class="sd">            :getter: Get the array of the boundary information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span>

<div class="viewcode-block" id="SchismMesh.n_boundaries"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.n_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">n_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the number of boundaries. If a boundary type is given,</span>
<span class="sd">            it counts only boundaries with the corresponding type.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            btype: integer, optional</span>
<span class="sd">                Type of the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">btype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span>
                       <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">btype</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismMesh.n_total_boundary_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.n_total_boundary_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">n_total_boundary_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">btype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total node boundary of a given type</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            btype: integer</span>
<span class="sd">                Type of the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span>
                   <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">btype</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismMesh.add_boundary"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.add_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">add_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">btype</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add one boundary.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            nodes: an array of integer</span>
<span class="sd">                array of inter node indexes in the boundary path</span>

<span class="sd">            btype: integer</span>
<span class="sd">                an integer constant for boundary types.</span>

<span class="sd">            comment: optional, string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rearrange_boundary_nodes_in_ccw</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="c1"># Call the super class method first</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SchismMesh</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">btype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SchismBoundary</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">btype</span><span class="p">,</span> <span class="n">comment</span><span class="p">))</span></div>

<div class="viewcode-block" id="SchismMesh.clear_boundaries"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.clear_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">clear_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Delete all the current boundary information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_edge_types</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_check_if_beginning_of_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check if the given node is any of starting nodes of boundary</span>
<span class="sd">            node strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">btype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_i</span> <span class="o">==</span> <span class="n">boundary</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">boundary</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">btype</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node_i</span> <span class="o">==</span> <span class="n">boundary</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_next_node_on_boundary_and_remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">,</span>
                                                   <span class="n">not_assigned</span><span class="p">,</span>
                                                   <span class="n">ccw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">edges_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">node_i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="n">edges_i</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ccw</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">not_assigned</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge_i</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempted to remove edge </span><span class="si">{}</span><span class="s2"> based on node </span><span class="si">{}</span><span class="s2"> which is not in not_assigned list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_i</span><span class="p">,</span><span class="n">node_i</span><span class="p">))</span>
                        <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                    <span class="n">not_assigned</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge_i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_fill_land_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates land boundaries that are adjacent to</span>
<span class="sd">        the open boundaries. The direction of the filling is CCW.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># No open boundary at all?</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">open_boundary</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">:</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">open_boundary</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Check if there is another boundary right next this</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_beginning_of_boundary</span><span class="p">(</span><span class="n">last</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                        <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_node_on_boundary</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
                        <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_beginning_of_boundary</span><span class="p">(</span><span class="n">next_node</span><span class="p">):</span>
                            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">last</span> <span class="o">=</span> <span class="n">next_node</span>

    <span class="k">def</span> <span class="nf">_fill_island_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">not_assigned</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function fills missing island boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">first_node_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">not_assigned</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_node_i</span><span class="p">)</span>
        <span class="n">last_node_i</span> <span class="o">=</span> <span class="n">first_node_i</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_node_on_boundary_and_remove_edge</span><span class="p">(</span>
                <span class="n">last_node_i</span><span class="p">,</span> <span class="n">not_assigned</span><span class="p">)</span>
            <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">first_node_i</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">ISLAND</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last_node_i</span> <span class="o">=</span> <span class="n">next_node</span>

    <span class="k">def</span> <span class="nf">_get_not_assigned_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get all edges that are not assigned as boundaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">notypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_edges_from_elems</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">BOUNDARY</span><span class="p">:</span>
                <span class="n">notypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">notypes</span>

<div class="viewcode-block" id="SchismMesh.fill_land_and_island_boundaries"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.fill_land_and_island_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">fill_land_and_island_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fill land and island boundaries for boundary edges not assigned</span>
<span class="sd">        to boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_land_boundaries</span><span class="p">()</span>
        <span class="n">not_assigned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_not_assigned_boundary_edges</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_assigned</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fill_island_boundaries</span><span class="p">(</span><span class="n">not_assigned</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span></div>

<div class="viewcode-block" id="SchismMesh.fill_open_boundaries"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.fill_open_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">fill_open_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fill open boundaries for boundary edges not assigned</span>
<span class="sd">        to boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># No boundaries defined</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No boundaries are defined&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">:</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Check if there is another boundary right next this</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_beginning_of_boundary</span><span class="p">(</span><span class="n">last</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_node_on_boundary</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
                        <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_beginning_of_boundary</span><span class="p">(</span><span class="n">next_node</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">)</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">last</span> <span class="o">=</span> <span class="n">next_node</span></div>

<div class="viewcode-block" id="SchismMesh.find_two_neighboring_node_paths"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.find_two_neighboring_node_paths">[docs]</a>    <span class="k">def</span> <span class="nf">find_two_neighboring_node_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find two neighboring node paths around a line_segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        line_segment: array-like</span>
<span class="sd">            two end points of the line segment, start_x, start_y, end_x, end_y</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        up_path: array of int</span>
<span class="sd">            upstream side of node paths</span>
<span class="sd">        down_path: array of int</span>
<span class="sd">            downstream side of node paths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Accessing parent class data directly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">_line</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">_line</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">]</span>

        <span class="c1"># normal = np.array((x[1, 1] - x[0, 1], x[0, 0] - x[1, 0]))</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_from_points</span><span class="p">(</span><span class="n">_line</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">intersected_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="n">nodes_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_i</span><span class="p">)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">nodes_i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="n">find_intersection</span><span class="p">(</span><span class="n">_line</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">intersection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">nodes_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes_i</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_nodes</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">intersected_edges</span><span class="p">:</span>
                        <span class="n">intersected_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                        <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">]</span>
        <span class="n">edges_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">intersected_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dists</span><span class="p">)]</span>

        <span class="n">up_path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">down_path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tan</span> <span class="o">=</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="n">tan</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tan</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_sorted</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">down_path</span><span class="p">:</span>
                    <span class="n">down_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">up_path</span><span class="p">:</span>
                    <span class="n">up_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">up_path</span><span class="p">:</span>
                    <span class="n">up_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">down_path</span><span class="p">:</span>
                    <span class="n">down_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>

        <span class="c1"># Check if node strings are continuous and if not fix it</span>
        <span class="c1"># Up to quad elements are assumed.</span>
        <span class="n">up_path_updated</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">up_path</span><span class="p">)</span>
        <span class="n">n_inserted_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">up_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">((</span><span class="n">up_path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">up_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">elem_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">up_path</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">up_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="n">nodes_in_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_up</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">nodes_in_elem</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node_i</span> <span class="o">!=</span> <span class="n">up_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">node_i</span> <span class="o">!=</span> <span class="n">up_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">node_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">down_path</span><span class="p">:</span>
                        <span class="n">up_path_updated</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                            <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_inserted_nodes</span><span class="p">,</span> <span class="n">node_i</span><span class="p">)</span>
                        <span class="n">n_inserted_nodes</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>

        <span class="n">down_path_updated</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">down_path</span><span class="p">)</span>
        <span class="n">n_inserted_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">down_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">((</span><span class="n">down_path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">down_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">elem_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">down_path</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">down_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="n">nodes_in_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_up</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">nodes_in_elem</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node_i</span> <span class="o">!=</span> <span class="n">down_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">node_i</span> <span class="o">!=</span> <span class="n">down_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">node_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">up_path</span><span class="p">:</span>
                        <span class="n">down_path_updated</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                            <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_inserted_nodes</span><span class="p">,</span> <span class="n">node_i</span><span class="p">)</span>
                        <span class="n">n_inserted_nodes</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">up_path_updated</span><span class="p">,</span> <span class="n">down_path_updated</span></div>

    <span class="k">def</span> <span class="nf">_order_up_nodes_from_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Order up nodes based on the distance from x</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            nodes:</span>
<span class="sd">                list of node indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">sorted_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_indexes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sorted_</span>

    <span class="k">def</span> <span class="nf">_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate a distance from a node[node_i] to a point x(x1, x2)</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes_i</span><span class="p">)</span>
        <span class="n">diffs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">diffs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dist</span>

    <span class="k">def</span> <span class="nf">_rearrange_boundary_nodes_in_ccw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make sure the boundary nodes are in CCW ordering.</span>
<span class="sd">            Assume that nodes are in row at least.</span>
<span class="sd">            nodes = the list of node indexes</span>
<span class="sd">            return = reordered list of the node indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">nodes</span>
            <span class="k">return</span> <span class="n">new_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nodes</span>

<div class="viewcode-block" id="SchismMesh.trim_to_left_of_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.trim_to_left_of_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">trim_to_left_of_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Trim mesh using line_segments.</span>
<span class="sd">            This function trims the mesh on the left sides</span>
<span class="sd">            of the line segments. The left side here means left when you look</span>
<span class="sd">            at the second end point of a line segment from the first one.</span>
<span class="sd">            An actual path to trimming is a nodal path that is on the</span>
<span class="sd">            right side of the line segment.</span>
<span class="sd">            To manage torus like mesh topology, the argument takes an array</span>
<span class="sd">            of line segments. The user need to provides a set of line segments</span>
<span class="sd">            to make sure the left side of the line segments does not</span>
<span class="sd">            cover the whole mesh.</span>
<span class="sd">            To trim multiple parts of a mesh, use this function</span>
<span class="sd">            multiple times.</span>
<span class="sd">            This function clears up any boundary definitions associated with</span>
<span class="sd">            the original grid. It is user&#39;s responsibility to create them</span>
<span class="sd">            again.</span>

<span class="sd">            line_segments = array of line segments defined by two end points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># self._logger.info(&quot;Trimming the mesh...&quot;)</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line_segments</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_two_neighboring_node_paths</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim_elems</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_boundaries</span><span class="p">()</span></div>
        <span class="c1"># self._logger.info(&quot;Removed the old boundary information.&quot;)</span>

<div class="viewcode-block" id="SchismMesh.build_z"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.build_z">[docs]</a>    <span class="k">def</span> <span class="nf">build_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elev</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build vertical coordinates</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No vertical mesh information&quot;</span><span class="p">)</span>
        <span class="c1"># NOTE: Possibility of cyclic reference</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmesh</span><span class="o">.</span><span class="n">build_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elev</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elevation of levels at all the nodes</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Depth array of each levels at the nodes.</span>
<span class="sd">                The shape of the array is (n_nodes, n_vert_levels)</span>
<span class="sd">                The levels below the most bottom level will be filled with</span>
<span class="sd">                the elevation of the bottom level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmesh</span><span class="o">.</span><span class="n">_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_z</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmesh</span><span class="o">.</span><span class="n">_z</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_vert_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmesh</span><span class="o">.</span><span class="n">n_vert_levels</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No vertical mesh is provided&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SchismMesh.get_coordinates_3d"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.get_coordinates_3d">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the array of each 3-d nodes</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Array of 3-d coordinates</span>
<span class="sd">                The shape of the array is (n_nodes * n_vert_levels, 3)</span>
<span class="sd">                The points below the most bottom level will be filled with</span>
<span class="sd">                the elevation of the the bottom level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">()</span>
        <span class="n">n_vert_levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmesh</span><span class="o">.</span><span class="n">n_vert_levels</span><span class="p">()</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_nodes</span> <span class="o">*</span> <span class="n">n_vert_levels</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vert_levels</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n_vert_levels</span> <span class="o">+</span> <span class="n">j</span>
                <span class="n">points</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">points</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">points</span></div>

<div class="viewcode-block" id="SchismMesh.get_centers_of_elements"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.get_centers_of_elements">[docs]</a>    <span class="k">def</span> <span class="nf">get_centers_of_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the array of the centers of the element</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Array of 2-d coordinates of the centers of the elements</span>
<span class="sd">                The shape of the array is (n_elems, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">(),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">):</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">centers</span></div>

<div class="viewcode-block" id="SchismMesh.get_centers_of_sides"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.get_centers_of_sides">[docs]</a>    <span class="k">def</span> <span class="nf">get_centers_of_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the array of the centers of the sides</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Array of 3-d coordinates of the centers of the elements</span>
<span class="sd">                The shape of the array is (n_elems, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span><span class="p">(),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">centers</span></div>

<div class="viewcode-block" id="SchismMesh.areas"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.areas">[docs]</a>    <span class="k">def</span> <span class="nf">areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the array of element areas</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_areas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_areas</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_areas</span></div>

    <span class="k">def</span> <span class="nf">_create_2d_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_create_2d_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="p">:])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_calculate_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the areas of the elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_2d_polygons</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_calculate_edge_lens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the lengths of the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the centroids of all the elements</span>
<span class="sd">            NOTE: Assume that the polygons are simple polygons</span>
<span class="sd">            that do not consist of multiple parts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_2d_polygons</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">])</span>

<div class="viewcode-block" id="SchismMesh.edge_len"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.edge_len">[docs]</a>    <span class="k">def</span> <span class="nf">edge_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a NumPy array of edge lengths</span>
<span class="sd">            The ordering of the edges is decided from triquadmesh.</span>
<span class="sd">            Look edges properties to find out connectivity</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_edge_lens</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_lengths</span></div>

<div class="viewcode-block" id="SchismMesh.centroids"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.centroids">[docs]</a>    <span class="k">def</span> <span class="nf">centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a Numpy array of element centroids</span>
<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_centroids</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span></div>

<div class="viewcode-block" id="SchismMesh.merged_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.merged_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">merged_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        merge all the meshes to create a boundary polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merged_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">cascaded_union</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_2d_polygons</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_merged_mesh</span> <span class="o">=</span> <span class="n">cascaded_union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merged_mesh</span></div>

<div class="viewcode-block" id="SchismMesh.to_geopandas"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.to_geopandas">[docs]</a>    <span class="k">def</span> <span class="nf">to_geopandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">feature_type</span><span class="o">=</span><span class="s1">&#39;polygon&#39;</span><span class="p">,</span><span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">shp_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">node_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">elem_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">edge_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">value_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">create_gdf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create mesh polygon and points as geopandas dataframe and shapefiles if</span>
<span class="sd">        Shap_fn file name is supplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;polygon&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_2d_polygons</span><span class="p">()</span>
            <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span>
            <span class="k">if</span> <span class="n">elem_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">value_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem_values</span>
        <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;point&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_2d_points</span><span class="p">()</span>
            <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>
            <span class="k">if</span> <span class="n">node_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">value_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_values</span>
        <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
            <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centers_of_sides</span><span class="p">()[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">value_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_values</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">features</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">crs</span><span class="p">:</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">shp_fn</span><span class="p">:</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shp_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">create_gdf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="SchismMesh.plot_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.plot_elems">[docs]</a>    <span class="k">def</span> <span class="nf">plot_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">inpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plot_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot variables (1D array on element) based on SCHISM mesh grid.</span>
<span class="sd">        if var is None,just plot the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input var has different len compared to input elem&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inpoly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy</span><span class="p">)[</span><span class="n">inpoly</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_nan</span><span class="p">:</span>
                    <span class="n">vpoly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="c1"># do not plot nan data</span>
                    <span class="n">inpoly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">inpoly</span><span class="p">,</span> <span class="o">~</span><span class="n">vpoly</span><span class="p">)</span>
            <span class="n">coll</span> <span class="o">=</span> <span class="n">PolyCollection</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="n">array</span><span class="o">=</span><span class="n">var</span><span class="p">[</span><span class="n">inpoly</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plot_nan</span><span class="p">:</span>
                <span class="n">coll</span> <span class="o">=</span> <span class="n">PolyCollection</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="n">array</span><span class="o">=</span><span class="n">var</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inpoly</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy</span><span class="p">)[</span><span class="n">inpoly</span><span class="p">]</span>
                <span class="n">coll</span> <span class="o">=</span> <span class="n">PolyCollection</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="n">array</span><span class="o">=</span><span class="n">var</span><span class="p">[</span><span class="n">inpoly</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coll</span></div>

<div class="viewcode-block" id="SchismMesh.plot_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.plot_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">plot_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">inpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plot_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input var has different len compared to input node&quot;</span><span class="p">)</span>
        <span class="n">velem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">var</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inpoly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inpoly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">inpoly</span><span class="p">[</span><span class="n">el</span><span class="p">])</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">])</span>
        <span class="n">coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_elems</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">velem</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">inpoly</span><span class="o">=</span><span class="n">inpoly</span><span class="p">,</span><span class="n">plot_nan</span><span class="o">=</span><span class="n">plot_nan</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coll</span></div>

<div class="viewcode-block" id="SchismMesh.plot_edges"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.plot_edges">[docs]</a>    <span class="k">def</span> <span class="nf">plot_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">inpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_centers_of_sides</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input var has different len compared to input edge&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">inpoly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centers_of_sides</span><span class="p">()[</span><span class="n">inpoly</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">sca_plt</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">var</span><span class="p">[</span><span class="n">inpoly</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">sca_plt</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sca_plt</span></div>

<div class="viewcode-block" id="SchismMesh.plot_mesh_boundary"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.SchismMesh.plot_mesh_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mesh_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the edge of the computational grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundary_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_mesh</span><span class="p">()</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary_mesh</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="n">multi_poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary_mesh</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multi_poly</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">boundary_mesh</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">multi_poly</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pi</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">):</span>
                <span class="n">boundary</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pi</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">:</span>
                    <span class="n">cxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">patch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pi</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">boundary_mesh</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div></div>

<span class="k">class</span> <span class="nc">SchismMeshReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Schism Mesh Reader abstract class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">SchismMeshWriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Schism Mesh Writer abstract class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">SchismMeshGr3Reader</span><span class="p">(</span><span class="n">SchismMeshReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read a mesh from a GR3 file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">read_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="c1"># First line</span>
        <span class="n">first_line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1"># Second line: # of elements and # of nodes</span>
        <span class="n">tkns</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not enough items is the second line&#39;</span><span class="p">)</span>
        <span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tkns</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">n_elems</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_nodes</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid # of elems or nodes&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)</span>  <span class="c1"># Allocate memory</span>

    <span class="k">def</span> <span class="nf">read_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="n">node_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">()):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node block is corrupt.&quot;</span><span class="p">)</span>
            <span class="n">node_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">tkns</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">set_node</span><span class="p">(</span><span class="n">node_counter</span><span class="p">,</span> <span class="n">node_coords</span><span class="p">)</span>
            <span class="n">node_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">read_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">tkn</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element block is corrupt&quot;</span><span class="p">)</span>
            <span class="n">type_elem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">type_elem</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">type_elem</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Only triangular or quadrilateral are supported.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element block is corrupt&quot;</span><span class="p">)</span>
            <span class="c1"># Zero-based connectivities</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">type_elem</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">connectivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tkn</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]))),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">type_elem</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">connectivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tkn</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]))),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element block is corrupt&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element block is corrupt&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">set_elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">,</span> <span class="n">connectivities</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read boundary information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open boundaries</span>
        <span class="c1"># # of open boundaries</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No boundary information is present?&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_open_boundaries</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
            <span class="n">n_open_boundary_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_open_boundaries</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
                <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                    <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Zero based</span>
                    <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span>
                                        <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">)</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
            <span class="n">n_land_boundaries</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
            <span class="n">n_land_boundary_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_land_boundaries</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
                <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                    <span class="n">tkns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tkns</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error reading: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tkns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Zero based</span>
                    <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span>
                                        <span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary block is corrupt&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a hgrid.gr3 file.</span>
<span class="sd">            If mode is 1, it does not read in boundary information.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            SchismMesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fpath_mesh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fpath_mesh&#39;</span><span class="p">,</span> <span class="s1">&#39;hgrid.gr3&#39;</span><span class="p">)</span>
        <span class="n">read_boundary</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;read_boundary&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fpath_mesh</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">read_boundary</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File not found:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reading in a gr3 file: </span><span class="si">%s</span><span class="s2"> ...&quot;</span> <span class="o">%</span> <span class="n">fpath_mesh</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="n">SchismMesh</span><span class="p">()</span>
        <span class="c1"># Horizontal mesh</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_nodes</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_elems</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="c1"># Boundary info</span>
            <span class="k">if</span> <span class="n">read_boundary</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_boundaries</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span>


<span class="k">class</span> <span class="nc">SchismMeshSmsReader</span><span class="p">(</span><span class="n">SchismMeshReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read a mesh from a 2dm file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">SchismMesh</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">read_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;MESH2D&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not supported 2dm format&quot;</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;MESHNAME&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">_metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No mesh name in 2dm file&quot;</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">prepare_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_n_nodes</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
        <span class="n">n_elems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_n_elements</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)</span>  <span class="c1"># Allocate memory</span>

    <span class="k">def</span> <span class="nf">read_n_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
        <span class="n">n_elems</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;E3T&#39;</span><span class="p">,</span> <span class="s1">&#39;E4Q&#39;</span><span class="p">):</span>
                    <span class="n">n_elems</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n_elems</span>

    <span class="k">def</span> <span class="nf">read_n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ND&#39;</span><span class="p">:</span>
                    <span class="n">n_nodes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n_nodes</span>

    <span class="k">def</span> <span class="nf">read_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="n">elem_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;E3T&#39;</span><span class="p">,</span> <span class="s1">&#39;E4Q&#39;</span><span class="p">):</span>
                    <span class="c1"># elem_i = int(row[1]) - 1</span>
                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;E3T&#39;</span><span class="p">:</span>
                        <span class="n">connectivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]))),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;E4Q&#39;</span><span class="p">:</span>
                        <span class="n">connectivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]))),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element block is corrupt&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">set_elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">,</span> <span class="n">connectivities</span><span class="p">)</span>
                    <span class="n">elem_i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">read_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ND&#39;</span><span class="p">:</span>
                    <span class="n">node_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">node_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">set_node</span><span class="p">(</span><span class="n">node_i</span><span class="p">,</span> <span class="n">node_coords</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bad node: . This can be caused by deleting nodes in SMS and failing to renumber:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_i</span><span class="p">))</span>
                        <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">read_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath</span><span class="p">,</span> <span class="n">nodestring_option</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in nodestrings as boundaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodestring_option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="n">bound_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NS&#39;</span><span class="p">:</span>
                    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                    <span class="k">if</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">bound_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">nodestring_option</span> <span class="o">==</span> <span class="s1">&#39;open&#39;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span>
                                <span class="n">bound_nodes</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">nodestring_option</span> <span class="o">==</span> <span class="s1">&#39;land&#39;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span>
                                <span class="n">bound_nodes</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;boundary_assignment&#39;</span><span class="p">,</span> <span class="n">nodestring_option</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not supported option&#39;</span><span class="p">)</span>
                        <span class="n">bound_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bound_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nodestring_option</span> <span class="o">==</span> <span class="s1">&#39;open&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">fill_land_and_island_boundaries</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">fill_open_boundaries</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">fpath_mesh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fpath_mesh&#39;</span><span class="p">,</span> <span class="s1">&#39;hgrid.gr3&#39;</span><span class="p">)</span>
        <span class="n">nodestring_option</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nodestring_option&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fpath_mesh</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_mesh</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_elements</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_nodes</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_boundary</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">,</span> <span class="n">nodestring_option</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>


<span class="k">class</span> <span class="nc">SchismMeshGr3Writer</span><span class="p">(</span><span class="n">SchismMeshWriter</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_write_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
        <span class="c1"># Open</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> = Number of open boundaries</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_boundaries</span><span class="p">(</span>
            <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> = Total number of open boundary nodes</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_total_boundary_nodes</span><span class="p">(</span>
            <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">openbound_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bndry</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bndry</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
                <span class="n">openbound_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">bndry</span><span class="o">.</span><span class="n">comment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> = Number of nodes for open boundary </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> \
                          <span class="p">(</span><span class="n">bndry</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(),</span> <span class="n">openbound_count</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bndry</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(),</span> <span class="n">bndry</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">bndry</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     raise ValueError(&quot;Unsupported boundary type.&quot;)</span>

        <span class="c1"># Land &amp; Island</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> = Number of land boundaries</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">n_boundaries</span><span class="p">(</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">n_boundaries</span><span class="p">(</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">ISLAND</span><span class="p">))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> = Total number of land boundary nodes</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">n_total_boundary_nodes</span><span class="p">(</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">n_total_boundary_nodes</span><span class="p">(</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">ISLAND</span><span class="p">))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">landbound_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bndry</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bndry</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span> <span class="ow">or</span>
                <span class="n">bndry</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">ISLAND</span><span class="p">):</span>
                <span class="n">landbound_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">island_flag</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">bndry</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">bndry</span><span class="o">.</span><span class="n">comment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> = Number of nodes for land boundary </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> \
                        <span class="p">(</span><span class="n">bndry</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(),</span> <span class="n">island_flag</span><span class="p">,</span> <span class="n">landbound_count</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bndry</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(),</span> <span class="n">island_flag</span><span class="p">,</span> <span class="n">bndry</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">bndry</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a GR3 format grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh: SchismMesh</span>
<span class="sd">            a mesh to write</span>
<span class="sd">        fpath: str</span>
<span class="sd">            output file name</span>
<span class="sd">        node_attr: array-like, optional</span>
<span class="sd">            a list of node attribute. If provided, this will replace depth.</span>
<span class="sd">        boundary: boolean, optional</span>
<span class="sd">            default = True</span>
<span class="sd">            If true, boundary information will be written.</span>
<span class="sd">            Otherwise, it will not be appended.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fpath&#39;</span><span class="p">)</span>
        <span class="n">node_attr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_attr&#39;</span><span class="p">)</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;write_boundary&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fpath</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">node_attr</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">boundary</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
            <span class="c1"># Header</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

            <span class="n">n_elems</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">()</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> ! # of elements and nodes</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

            <span class="n">padding</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">maxnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)))</span> <span class="o">+</span> <span class="n">padding</span>
            <span class="n">ifmtj</span> <span class="o">=</span> <span class="s2">&quot;%-&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2">i&quot;</span> <span class="o">%</span> <span class="n">maxnum</span><span class="p">)</span>
            <span class="n">ffmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%18.8f</span><span class="s2">&quot;</span>
            <span class="n">nfmt</span> <span class="o">=</span> <span class="n">ifmtj</span> <span class="o">+</span> <span class="n">ffmt</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="c1"># Nodes</span>
            <span class="k">if</span> <span class="n">node_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="n">nfmt</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                  <span class="n">node_attr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="n">nfmt</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                  <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

            <span class="c1"># Elements</span>
            <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_elems</span><span class="p">):</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">n_nodes_in_elem</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">elem_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_nodes_in_elem</span><span class="p">)</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="n">n_nodes_in_elem</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

            <span class="c1"># Boundaries</span>
            <span class="k">if</span> <span class="n">boundary</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_boundary</span><span class="p">()</span>


<span class="c1">#class SchismMeshShapefileWriter(SchismMeshWriter):</span>
<span class="c1">#</span>
<span class="c1">#    def write(self,  *args, **kwargs):</span>
<span class="c1">#        &quot;&quot;&quot; Write a shapefile of the mesh</span>
<span class="c1">#            Support only UTM10N at the moment</span>
<span class="c1">#</span>
<span class="c1">#            Parameters</span>
<span class="c1">#            ----------</span>
<span class="c1">#            mesh: SchismMesh</span>
<span class="c1">#            fpath: str</span>
<span class="c1">#                output file name</span>
<span class="c1">#            node_attr: numpy.array</span>
<span class="c1">#                node values to overwrite</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        mesh = kwargs.get(&#39;mesh&#39;)</span>
<span class="c1">#        fpath = kwargs.get(&#39;fpath&#39;)</span>
<span class="c1">#        node_attr = kwargs.get(&#39;node_attr&#39;)</span>
<span class="c1">#        for i, arg in enumerate(args):</span>
<span class="c1">#            if i == 0:</span>
<span class="c1">#                mesh = arg</span>
<span class="c1">#            elif i == 1:</span>
<span class="c1">#                fpath = arg</span>
<span class="c1">#            elif i == 2:</span>
<span class="c1">#                node_attr = arg</span>
<span class="c1">#</span>
<span class="c1">#        if os.path.exists(fpath):</span>
<span class="c1">#            print(&quot;File with the output file name exists already&quot;, fpath)</span>
<span class="c1">#            raise RuntimeError(&quot;File exists already&quot;)</span>
<span class="c1">#</span>
<span class="c1">#        spatial_reference = osgeo.osr.SpatialReference()</span>
<span class="c1">#        crs = kwargs.get(&#39;crs&#39;)</span>
<span class="c1">#        if crs is None:</span>
<span class="c1">#            crs = &#39;EPSG:26910&#39;</span>
<span class="c1">#        spatial_reference.ImportFromProj4(crs)</span>
<span class="c1">#        driver_name = &#39;ESRI Shapefile&#39;</span>
<span class="c1">#        driver = osgeo.ogr.GetDriverByName(driver_name)</span>
<span class="c1">#        if driver is None:</span>
<span class="c1">#            print(&#39;%s is not available.&#39; % driver_name)</span>
<span class="c1">#            raise RuntimeError()</span>
<span class="c1">#        datasource = driver.CreateDataSource(str(fpath))</span>
<span class="c1">#        if datasource is None:</span>
<span class="c1">#            raise RuntimeError()</span>
<span class="c1">#        layer = datasource.CreateLayer(&#39;mesh&#39;,</span>
<span class="c1">#                                       spatial_reference,</span>
<span class="c1">#                                       osgeo.ogr.wkbPolygon)</span>
<span class="c1">#        for i in range(4):</span>
<span class="c1">#            field = osgeo.ogr.FieldDefn(&#39;node%d&#39; % i, osgeo.ogr.OFTInteger)</span>
<span class="c1">#            layer.CreateField(field)</span>
<span class="c1">#        field = osgeo.ogr.FieldDefn(&#39;cell&#39;, osgeo.ogr.OFTInteger)</span>
<span class="c1">#        layer.CreateField(field)</span>
<span class="c1">#        feature_defn = layer.GetLayerDefn()</span>
<span class="c1">#        feature = osgeo.ogr.Feature(feature_defn)</span>
<span class="c1">#        ring = osgeo.ogr.Geometry(osgeo.ogr.wkbLinearRing)</span>
<span class="c1">#        polygon = osgeo.ogr.Geometry(osgeo.ogr.wkbPolygon)</span>
<span class="c1">#</span>
<span class="c1">#        nodes = mesh.nodes</span>
<span class="c1">#        elems = mesh.elems</span>
<span class="c1">#        for cell_i, cell in enumerate(elems):</span>
<span class="c1">#            for i, node_index in enumerate(cell):</span>
<span class="c1">#                node = nodes[node_index]</span>
<span class="c1">#                ring.AddPoint(*node)</span>
<span class="c1">#                feature.SetField(i, int(node_index))</span>
<span class="c1">#            feature.SetField(4, int(cell_i))</span>
<span class="c1">#            ring.AddPoint(*nodes[cell[0]])</span>
<span class="c1">#            polygon.AddGeometry(ring)</span>
<span class="c1">#            feature.SetGeometry(polygon)</span>
<span class="c1">#            layer.CreateFeature(feature)</span>
<span class="c1">#            ring.Empty()</span>
<span class="c1">#            polygon.Empty()</span>
<span class="c1">#        datasource.Destroy()</span>

<span class="k">class</span> <span class="nc">SchismMeshShapefileWriter</span><span class="p">(</span><span class="n">SchismMeshWriter</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a shapefile of the mesh</span>
<span class="sd">            Support only UTM10N at the moment</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh: SchismMesh</span>
<span class="sd">            fpath: str</span>
<span class="sd">                output file name</span>
<span class="sd">            node_attr: numpy.array</span>
<span class="sd">                node values to overwrite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
        <span class="kn">import</span> <span class="nn">logging</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fpath&#39;</span><span class="p">)</span>
        <span class="n">node_attr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_attr&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fpath</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">node_attr</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fpath</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File with the output file name exists already&quot;</span><span class="p">,</span> <span class="n">fpath</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;File exists already&quot;</span><span class="p">)</span>

        <span class="n">crs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;crs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="s1">&#39;EPSG:26910&#39;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">node_values</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">value_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Two shape files will be generated, one for the polygons and the other</span>
        <span class="c1"># for the nodes.</span>

        <span class="n">node_values</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">value_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Two shape files will be generated, one for the polygons and the other</span>
        <span class="c1"># for the nodes.</span>
        <span class="n">fpath_str</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
        <span class="n">fdir</span> <span class="o">=</span> <span class="n">fpath_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">fpath_str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.shp&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">fpath_poly</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fdir</span><span class="p">,</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;_polygon.shp&#39;</span><span class="p">)</span>
        <span class="n">fpath_point</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fdir</span><span class="p">,</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;_point.shp&#39;</span><span class="p">)</span>

        <span class="n">mesh</span><span class="o">.</span><span class="n">to_geopandas</span><span class="p">(</span><span class="s1">&#39;polygon&#39;</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">fpath_poly</span><span class="p">,</span> <span class="n">create_gdf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">to_geopandas</span><span class="p">(</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">fpath_point</span><span class="p">,</span>
                          <span class="n">node_values</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="n">value_name</span><span class="p">,</span> <span class="n">create_gdf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> generated&quot;</span> <span class="o">%</span> <span class="n">fpath</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SchismMeshNetcdfWriter</span><span class="p">(</span><span class="n">SchismMeshWriter</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a netcdf of the mesh</span>
<span class="sd">            Support only UTM10N at the moment</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh: SchismMesh generated by read_mesh(gr3_fn)</span>
<span class="sd">            fpath: str</span>
<span class="sd">                output file name</span>
<span class="sd">            node_attr: numpy.array</span>
<span class="sd">                node values to overwrite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">logging</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fpath&#39;</span><span class="p">)</span>
        <span class="n">node_attr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_attr&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fpath</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">node_attr</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fpath</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File with the output file name exists already&quot;</span><span class="p">,</span> <span class="n">fpath</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;File exists already&quot;</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elems</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">#n_node = range(mesh.n_nodes())</span>
        <span class="c1">#n_face = range(mesh.n_elems())</span>
        <span class="c1">#n_edge = range(mesh.n_edges())</span>
        <span class="c1"># if less than 4 nodes, give a negative value</span>
        <span class="n">contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">elems</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">*-</span><span class="mf">99.99</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elems</span><span class="p">)):</span>
            <span class="n">mesh_nodes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]][:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># need to check if the mesh_nodes are consistenly in anti-clockwise direction</span>
            <span class="n">contour</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_nodes</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mesh_nodes</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">value_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.nc&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">n_face_node</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># maximum 4 nodes</span>

        <span class="c1"># the nc file generated may not exactly follow ugrid convention</span>
        <span class="n">ds_node_x</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># coords=[n_node],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_node&#39;</span><span class="p">],</span>
                                 <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_node_x&#39;</span><span class="p">)</span>
        <span class="n">ds_node_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;node x-coordinate&quot;</span>
        <span class="n">ds_node_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;longitude&#39;</span>
        <span class="c1"># alternatively, degrees lat/lon</span>
        <span class="n">ds_node_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees_east&quot;</span>
        <span class="n">ds_node_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
        <span class="n">ds_node_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>

        <span class="n">ds_node_y</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># coords=[n_node],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_node&#39;</span><span class="p">],</span>
                                 <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_node_y&#39;</span><span class="p">)</span>
        <span class="n">ds_node_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;node x-coordinate&quot;</span>
        <span class="n">ds_node_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;latitude&#39;</span>
        <span class="c1"># alternatively, degrees lat/lon</span>
        <span class="n">ds_node_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees_north&quot;</span>
        <span class="n">ds_node_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
        <span class="n">ds_node_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>

        <span class="n">ds_values</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span>  <span class="c1"># coords=[n_node],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_node&#39;</span><span class="p">],</span>
                                 <span class="n">name</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>
        <span class="n">ds_values</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Bathymetry&quot;</span>
        <span class="n">ds_values</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;meters&quot;</span>
        <span class="n">ds_values</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;down&quot;</span>
        <span class="n">ds_values</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
        <span class="n">ds_values</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>

        <span class="n">ds_elem_contour_x</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">contour</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># coords=[n_face,n_face_node],</span>
                                         <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_face&#39;</span><span class="p">,</span> <span class="s1">&#39;n_face_node&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_contour_x&#39;</span><span class="p">)</span>
        <span class="n">ds_elem_contour_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;x_coordinates of 2D mesh contour&quot;</span>
        <span class="c1"># alternatively, degrees lat/lon</span>
        <span class="n">ds_elem_contour_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degree_east&quot;</span>
        <span class="n">ds_elem_contour_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
        <span class="n">ds_elem_contour_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;contour&quot;</span>

        <span class="n">ds_elem_contour_y</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">contour</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># coords=[n_face,n_face_node],</span>
                                         <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_face&#39;</span><span class="p">,</span> <span class="s1">&#39;n_face_node&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_contour_y&#39;</span><span class="p">)</span>
        <span class="n">ds_elem_contour_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;y_coordinates of 2D mesh contour&quot;</span>
        <span class="c1"># alternatively, degrees lat/lon</span>
        <span class="n">ds_elem_contour_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degree_north&quot;</span>
        <span class="n">ds_elem_contour_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
        <span class="n">ds_elem_contour_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;contour&quot;</span>

        <span class="c1"># change from 0 based to 1 based.</span>
        <span class="n">schism_face_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">e</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="n">e</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elems</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ds_face_nodes</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">schism_face_node</span><span class="p">,</span>  <span class="c1"># coords=[n_face, n_face_node],</span>
                                     <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_face&#39;</span><span class="p">,</span> <span class="s1">&#39;n_face_node&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;hgrid_face_nodes&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
        <span class="n">ds_face_nodes</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Horizontal Element Table&quot;</span>
        <span class="n">ds_face_nodes</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;cf_role&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;face_node_connectivity&quot;</span>
        <span class="n">ds_face_nodes</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;start_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># edge to nodes; change from 0 based to 1 based.</span>
        <span class="n">schism_edge_nodes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ds_edge_nodes</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">schism_edge_nodes</span><span class="p">,</span>  <span class="c1"># coords=[n_edge,np.arange(2)],</span>
                                     <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_edge&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_edge_nodes&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
        <span class="n">ds_edge_nodes</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Map every edge to the two nodes that it connects&quot;</span>
        <span class="n">ds_edge_nodes</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;cf_role&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edge_node_connectivity&quot;</span>
        <span class="n">ds_edge_nodes</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;start_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">face_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span>
        <span class="n">ds_face_x</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">face_x</span><span class="p">,</span>  <span class="c1"># coords=[n_face],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_face&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_face_x&#39;</span><span class="p">)</span>
        <span class="n">ds_face_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;x_coordinate of 2D mesh face&quot;</span>
        <span class="n">ds_face_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;longitude&quot;</span>
        <span class="n">ds_face_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees_east&quot;</span>
        <span class="n">ds_face_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>

        <span class="n">face_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span>
        <span class="n">ds_face_y</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">face_y</span><span class="p">,</span>  <span class="c1"># coords=[n_face],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_face&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_face_y&#39;</span><span class="p">)</span>
        <span class="n">ds_face_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;y_coordinate of 2D mesh face&quot;</span>
        <span class="n">ds_face_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;latitude&quot;</span>
        <span class="n">ds_face_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees_north&quot;</span>
        <span class="n">ds_face_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>

        <span class="n">edge_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        <span class="n">ds_edge_x</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span>  <span class="c1"># coords=[n_edge],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_edge&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_edge_x&#39;</span><span class="p">)</span>
        <span class="n">ds_edge_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;x_coordinate of 2D mesh edge&quot;</span>
        <span class="n">ds_edge_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;longitude&quot;</span>
        <span class="n">ds_edge_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees_east&quot;</span>
        <span class="n">ds_edge_x</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>

        <span class="n">edge_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        <span class="n">ds_edge_y</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">edge_y</span><span class="p">,</span>  <span class="c1"># coords=[n_edge],</span>
                                 <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_edge&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hgrid_edge_y&#39;</span><span class="p">)</span>
        <span class="n">ds_edge_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;y_coordinate of 2D mesh edge&quot;</span>
        <span class="n">ds_edge_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;latitude&quot;</span>
        <span class="n">ds_edge_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees_north&quot;</span>
        <span class="n">ds_edge_y</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">ds_node_x</span><span class="p">,</span> <span class="n">ds_node_y</span><span class="p">,</span> <span class="n">ds_elem_contour_x</span><span class="p">,</span> <span class="n">ds_elem_contour_y</span><span class="p">,</span> <span class="n">ds_values</span><span class="p">,</span>
                       <span class="n">ds_face_nodes</span><span class="p">,</span> <span class="n">ds_edge_nodes</span><span class="p">,</span> <span class="n">ds_face_x</span><span class="p">,</span> <span class="n">ds_face_y</span><span class="p">,</span> <span class="n">ds_edge_x</span><span class="p">,</span> <span class="n">ds_edge_y</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;vmesh&#39;</span><span class="p">):</span>
            <span class="n">vmesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vmesh</span>
            <span class="n">n_vert_levels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">vmesh</span><span class="o">.</span><span class="n">n_vert_levels</span><span class="p">())</span>
            <span class="n">node_bottom_index</span> <span class="o">=</span> <span class="n">vmesh</span><span class="o">.</span><span class="n">kbps</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># from 0 based to 1 based.</span>
            <span class="n">ds_node_bottom</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">node_bottom_index</span><span class="p">,</span>  <span class="c1"># coords=[n_node],</span>
                                            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_node&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_bottom_index&#39;</span><span class="p">)</span>
            <span class="n">ds_node_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bottom level index at each node&quot;</span>
            <span class="n">ds_node_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;non-dimensional&quot;</span>
            <span class="n">ds_node_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
            <span class="n">ds_node_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>
            <span class="n">ds_node_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;start_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">ele_bottom_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">node_bottom_index</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span>
            <span class="n">ds_ele_bottom</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ele_bottom_index</span><span class="p">,</span>  <span class="c1"># coords=[n_face],</span>
                                            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_face&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ele_bottom_index&#39;</span><span class="p">)</span>
            <span class="n">ds_ele_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bottom level index at each element&quot;</span>
            <span class="n">ds_ele_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;non-dimensional&quot;</span>
            <span class="n">ds_ele_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
            <span class="n">ds_ele_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;elem&quot;</span>
            <span class="n">ds_ele_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;start_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">edge_bottom_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">node_bottom_index</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]])</span>
            <span class="n">ds_edge_bottom</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">edge_bottom_index</span><span class="p">,</span>  <span class="c1"># coords=[n_edge],</span>
                                            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_edge&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;edge_bottom_index&#39;</span><span class="p">)</span>
            <span class="n">ds_edge_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bottom level index at each edge&quot;</span>
            <span class="n">ds_edge_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;non-dimensional&quot;</span>
            <span class="n">ds_edge_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SCHISM_hgrid&quot;</span>
            <span class="n">ds_edge_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edge&quot;</span>
            <span class="n">ds_edge_bottom</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;start_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">z</span>
            <span class="n">ds_z</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">z</span><span class="p">,</span>  <span class="c1"># coords=[n_node,n_vert_levels],</span>
                                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;n_hgrid_node&#39;</span><span class="p">,</span> <span class="s1">&#39;n_vgrid_layers&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
            <span class="n">ds_z</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SCHISM_hgrid&#39;</span>
            <span class="n">ds_z</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;data_horizontal_center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;node&#39;</span>
            <span class="n">ds_z</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;data_vertical_center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full&#39;</span>
            <span class="n">ds_z</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;i23d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">ds_z</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;ivs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmesh</span><span class="o">.</span><span class="n">ivcor</span>

            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="p">[</span><span class="n">ds</span><span class="p">,</span> <span class="n">ds_node_bottom</span><span class="p">,</span> <span class="n">ds_ele_bottom</span><span class="p">,</span> <span class="n">ds_edge_bottom</span><span class="p">,</span> <span class="n">ds_z</span><span class="p">])</span>

        <span class="n">ds</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> generated&quot;</span> <span class="o">%</span> <span class="n">fpath</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SchismMeshIoFactory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A factory class for SchismMeshIo</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">registered_readers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gr3&#39;</span><span class="p">:</span> <span class="s1">&#39;SchismMeshGr3Reader&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;sms&#39;</span><span class="p">:</span> <span class="s1">&#39;SchismMeshSmsReader&#39;</span><span class="p">}</span>
    <span class="n">registered_writers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gr3&#39;</span><span class="p">:</span> <span class="s1">&#39;SchismMeshGr3Writer&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;shp&#39;</span><span class="p">:</span> <span class="s1">&#39;SchismMeshShapefileWriter&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;nc&#39;</span><span class="p">:</span> <span class="s1">&#39;SchismMeshNetcdfWriter&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_readers</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_readers</span><span class="p">[</span><span class="n">name</span><span class="p">]]()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not in SchismMeshIoFactory&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_registered_readers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_readers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_writers</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_writers</span><span class="p">[</span><span class="n">name</span><span class="p">]]()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not in SchismMeshIoFactory&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="read_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.read_mesh">[docs]</a><span class="k">def</span> <span class="nf">read_mesh</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">,</span> <span class="n">fpath_vmesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">old_vgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read a mesh data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SchismMesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">fpath_mesh</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.gr3&#39;</span><span class="p">):</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">SchismMeshIoFactory</span><span class="p">()</span><span class="o">.</span><span class="n">get_reader</span><span class="p">(</span><span class="s1">&#39;gr3&#39;</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fpath_vmesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vmesh</span> <span class="o">=</span> <span class="n">read_vmesh</span><span class="p">(</span><span class="n">fpath_vmesh</span><span class="p">,</span><span class="n">old_vgrid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">_vmesh</span> <span class="o">=</span> <span class="n">vmesh</span>
        <span class="k">if</span> <span class="s1">&#39;crs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mesh</span>
    <span class="k">elif</span> <span class="n">fpath_mesh</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.2dm&#39;</span><span class="p">):</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">SchismMeshIoFactory</span><span class="p">()</span><span class="o">.</span><span class="n">get_reader</span><span class="p">(</span><span class="s1">&#39;sms&#39;</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fpath_mesh</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;crs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported extension&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="write_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.write_mesh">[docs]</a><span class="k">def</span> <span class="nf">write_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fpath_mesh</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">write_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Write a horizontal mesh</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh: SchismMesh</span>
<span class="sd">            Mesh</span>
<span class="sd">        fpath_mesh: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fpath_mesh</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;gr3&#39;</span><span class="p">,</span> <span class="s1">&#39;ll&#39;</span><span class="p">,</span> <span class="s1">&#39;ic&#39;</span><span class="p">)):</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">SchismMeshIoFactory</span><span class="p">()</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="s1">&#39;gr3&#39;</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                     <span class="n">fpath</span><span class="o">=</span><span class="n">fpath_mesh</span><span class="p">,</span>
                     <span class="n">node_attr</span><span class="o">=</span><span class="n">node_attr</span><span class="p">,</span>
                     <span class="n">write_boundary</span><span class="o">=</span><span class="n">write_boundary</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fpath_mesh</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;shp&#39;</span><span class="p">)):</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">SchismMeshIoFactory</span><span class="p">()</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="s1">&#39;shp&#39;</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                     <span class="n">fpath</span><span class="o">=</span><span class="n">fpath_mesh</span><span class="p">,</span>
                     <span class="n">node_attr</span><span class="o">=</span><span class="n">node_attr</span><span class="p">,</span>
                     <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fpath_mesh</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;nc&#39;</span><span class="p">)):</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">SchismMeshIoFactory</span><span class="p">()</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="s1">&#39;nc&#39;</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                     <span class="n">fpath</span><span class="o">=</span><span class="n">fpath_mesh</span><span class="p">,</span>
                     <span class="n">node_attr</span><span class="o">=</span><span class="n">node_attr</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported extension&quot;</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">compare_mesh</span><span class="p">(</span><span class="n">mesh1</span><span class="p">,</span> <span class="n">mesh2</span><span class="p">,</span> <span class="n">dist_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For mesh2, find the nearest nodes in mesh1.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh1 : schism_mesh</span>
<span class="sd">        source mesh</span>
<span class="sd">        Generated by read_mesh(hgrid_fn)</span>
<span class="sd">    mesh2 : schism_mesh</span>
<span class="sd">        output_mesh</span>
<span class="sd">        Generated by read_mesh(hgrid_fn).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices: indices of the nearest nodes in mesh1</span>
<span class="sd">    dist: distances between the nearest nodes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh1_idx</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">Rtree</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh1</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">mesh1_idx</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">mesh2</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mesh1_idx</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">n2</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="p">(</span><span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">mesh1</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">n2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">mesh1</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist2</span><span class="p">))</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dist_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The overlapping nodes account for </span><span class="si">%s</span><span class="s2"> percent of total nodes&quot;</span><span class="o">%</span>
              <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">dist</span><span class="o">&lt;=</span><span class="n">dist_threshold</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">dist</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.schism_mesh</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, California Department of Water Resources.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>