
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>schimpy.trimesh &#8212; schimpy 1.4.2+0.g2629342.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo6.png" border="0" alt="Bay-Delta SELFE Tools"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.trimesh</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for schimpy.trimesh</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is a class to hold an unstructured triangular mesh.</span>

<span class="sd">Lots of the codes are copied from Rusty Chris Collerman&#39;s trigrid program</span>
<span class="sd">and modified a bit to meet our needs.</span>

<span class="sd">Prerequisite: Numpy, rtree package, and libspatialindex for rtree</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">##</span>
<span class="c1">## Author: Kijin Nam, knam@water.ca.gov</span>
<span class="c1">##</span>

<span class="kn">import</span> <span class="nn">schimpy.priority_queue</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">rtree</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">copy</span>

<div class="viewcode-block" id="enum"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.enum">[docs]</a><span class="k">def</span> <span class="nf">enum</span><span class="p">(</span><span class="o">**</span><span class="n">enums</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A enum type definition.</span>
<span class="sd">        Copied from http://stackoverflow.com/questions/36932/how-can-i-represent-an-enum-in-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;Enum&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="n">enums</span><span class="p">)</span></div>


<span class="c1"># Edge trait (or marker)</span>
<span class="n">INTERNAL_EDGE</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">BOUNDARY_EDGE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">OPEN_EDGE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">LAND_EDGE</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">ISLAND_EDGE</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">CUT_EDGE</span> <span class="o">=</span> <span class="mi">99</span>

<span class="n">EdgeTypes</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="n">INTERNAL_EDGE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">BOUNDARY_EDGE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">OPEN_EDGE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">LAND_EDGE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">ISLAND_EDGE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">CUT_EDGE</span> <span class="o">=</span> <span class="mi">99</span>
    <span class="p">)</span>

<span class="c1"># Boundary type</span>
<span class="n">INVALID_BOUNDARY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">OPEN_BOUNDARY</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">LAND_BOUNDARY</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">ISLAND_BOUNDARY</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">BoundaryTypes</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="n">INVALID_BOUNDARY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">OPEN_BOUNDARY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">LAND_BOUNDARY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">ISLAND_BOUNDARY</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="p">)</span>

<span class="n">BOUNDARY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">_XXYY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>


<div class="viewcode-block" id="TriMesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh">[docs]</a><span class="k">class</span> <span class="nc">TriMesh</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class that holds a triangular mesh information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor of TriMesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Rtree index for nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Rtree index for elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Rtree index for element centers</span>

<div class="viewcode-block" id="TriMesh.deepcopy"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Deep copy mesh information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Node array consisting of three-dimensional coordinates of each node.</span>
<span class="sd">            The shape of the array is (# of nodes, 3)</span>

<span class="sd">            :getter: Get the array of the nodes.</span>
<span class="sd">            :type: Numpy float array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Array of node indices of each element.</span>
<span class="sd">            The shape of the array is (# of elems, 3).</span>
<span class="sd">            It is assumed that all elems are triangular.</span>

<span class="sd">            :getter: Get the Numpy array of the node indices.</span>
<span class="sd">            :type: Numpy integer array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Array of edges</span>

<span class="sd">            :getter: Get the array of the edges.</span>
<span class="sd">            :type: Numpy integer array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span>

<div class="viewcode-block" id="TriMesh.allocate"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.allocate">[docs]</a>    <span class="k">def</span> <span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Allocate memory for nodes and elems</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            n_elems: integer</span>
<span class="sd">                Total number of elems</span>
<span class="sd">            n_nodes: integer</span>
<span class="sd">                Total number of nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1"># Elements up to 2,147,483,647</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_elems</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TriMesh.set_node"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.set_node">[docs]</a>    <span class="k">def</span> <span class="nf">set_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set one node information.</span>
<span class="sd">            Memory for nodes must be allocated already.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            index: integer</span>
<span class="sd">                Zero-based node index</span>
<span class="sd">            coords: Numpy array</span>
<span class="sd">                a Numpy array of node coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Accessing out of bound in node array&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">index</span><span class="p">,:</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="TriMesh.set_elem"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.set_elem">[docs]</a>    <span class="k">def</span> <span class="nf">set_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">connectivities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set element connectivity information.</span>
<span class="sd">            Memory for elems must be allocated already.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            index: integer</span>
<span class="sd">                Zero-based element index</span>
<span class="sd">            connectivities: Numpy array</span>
<span class="sd">                a Numpy array of element connectivity, which means node</span>
<span class="sd">                indies in the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Accessing out of bound in node array&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">index</span><span class="p">,]</span> <span class="o">=</span> <span class="n">connectivities</span></div>

<div class="viewcode-block" id="TriMesh.n_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.n_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total number of nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriMesh.n_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.n_elems">[docs]</a>    <span class="k">def</span> <span class="nf">n_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total nuber of elems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriMesh.n_edges"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.n_edges">[docs]</a>    <span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total number of edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_edges_from_elems</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriMesh.build_edges_from_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.build_edges_from_elems">[docs]</a>    <span class="k">def</span> <span class="nf">build_edges_from_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This is a function copied and modified from TriGrid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building edges from elements&quot;</span><span class="p">)</span>
        <span class="c1"># iterate over elements, and for each element, if it&#39;s index</span>
        <span class="c1"># is smaller than a neighbor or if no neighbor exists,</span>
        <span class="c1"># write an edge record</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this will get built on demand later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">elem_i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">):</span>
            <span class="c1"># find the neighbors:</span>
            <span class="c1"># the first neighbor: need another element that has</span>
            <span class="c1"># both self._elems[i,0] and self._elems[i,1] in its</span>
            <span class="c1"># list.</span>
            <span class="n">my_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">elem_i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">node_a</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">node_b</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>

                <span class="n">elem_ball_node_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">node_a</span><span class="p">)</span>
                <span class="n">elem_ball_node_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">node_b</span><span class="p">)</span>

                <span class="c1"># the intersection is us and our neighbor</span>
                <span class="c1"># so difference out ourselves...</span>
                <span class="n">adj_elem_of_edge</span> <span class="o">=</span> <span class="n">elem_ball_node_a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem_ball_node_b</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>
                <span class="c1"># and maybe we get a neighbor, maybe not (we&#39;re a boundary)</span>
                <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_elem_of_edge</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">adj_elem_i</span> <span class="o">=</span> <span class="n">adj_elem_of_edge</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">n_neighbors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">adj_elem_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot have more than two neighbors &quot;</span>
                                       <span class="s2">&quot;of one edge.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">adj_elem_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">elem_i</span> <span class="o">&lt;</span> <span class="n">adj_elem_i</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node_a</span><span class="p">,</span>
                                  <span class="n">node_b</span><span class="p">,</span>
                                  <span class="n">BOUNDARY_EDGE</span> <span class="k">if</span> <span class="n">adj_elem_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">INTERNAL_EDGE</span><span class="p">,</span>
                                  <span class="n">elem_i</span><span class="p">,</span> <span class="n">adj_elem_i</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_build_node_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building node indices...&quot;</span><span class="p">)</span>
            <span class="c1"># assemble points into list of (id, [x x y y], None)</span>
            <span class="c1"># but new rtree allows for interleaved coordinates all the time.</span>
            <span class="c1"># best solution probably to specify interleaved=False</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">_XXYY</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span> \
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())</span> \
                      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">Rtree</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">interleaved</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_elem_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Build Rtree index for elems</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building element indices...&quot;</span><span class="p">)</span>
            <span class="n">elem_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">:</span>
                <span class="c1"># TODO: This could be better with numpy.</span>
                <span class="n">box</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [xmin xmax ymin ymax]</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">element</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">elem_i</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">elem_i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">Rtree</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">interleaved</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="TriMesh.get_elems_i_from_node"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.get_elems_i_from_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_elems_i_from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get neighboring elements indexes of a node, so-called a ball.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mapping elements to nodes...&quot;</span><span class="p">)</span>
            <span class="c1"># build array for point-&gt;element lookup</span>
            <span class="c1"># Use set for later convenience</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())]</span>
            <span class="k">for</span> <span class="n">elem_i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">node_index</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_i</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">_find_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find an edge index with the two given node indices.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            nodes:</span>
<span class="sd">                two node indices</span>
<span class="sd">            direction:</span>
<span class="sd">                match the ordering of the nodes when an edge is found.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            int</span>
<span class="sd">                an edge index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">e</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">el1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">e</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="TriMesh.find_nodes_in_box"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.find_nodes_in_box">[docs]</a>    <span class="k">def</span> <span class="nf">find_nodes_in_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find nodse in a bounding box</span>
<span class="sd">            box = a numpy array of bounding box, [x_min, x_max, y_min, y_max]</span>
<span class="sd">            return = node indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_node_index</span><span class="p">()</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

    <span class="k">def</span> <span class="nf">_build_node2edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mapping nodes to edges...&quot;</span><span class="p">)</span>
        <span class="c1"># Build node2edges map</span>
        <span class="n">n2e</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())]</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">n2e</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="n">n2e</span>

        <span class="n">n2e</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())]</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">n2e</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="n">n2e</span>


<div class="viewcode-block" id="TriMesh.get_edges_from_node"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.get_edges_from_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges_from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get edge indices related to node_i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_node2edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="TriMesh.get_neighbor_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.get_neighbor_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbor_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get neighboring node indices from the given node index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_node2edges</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="TriMesh.add_boundary"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.add_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">add_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">btype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add boundary types to an edge with the given array of node indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_prev_i</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">edge_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">([</span><span class="n">node_prev_i</span><span class="p">,</span> <span class="n">node_i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">edge_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No edge found with the given nodes&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Trying to tag a non-boundary edge&#39;</span> \
                                <span class="s1">&#39;as boundary&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">btype</span> <span class="o">==</span> <span class="n">OPEN_BOUNDARY</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">OPEN_EDGE</span>
            <span class="k">elif</span> <span class="n">btype</span> <span class="o">==</span> <span class="n">LAND_BOUNDARY</span> <span class="ow">or</span> <span class="n">btype</span> <span class="o">==</span> <span class="n">ISLAND_BOUNDARY</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">LAND_EDGE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unsupported boundary type&quot;</span><span class="p">)</span>
            <span class="n">node_prev_i</span> <span class="o">=</span> <span class="n">node_i</span></div>

<div class="viewcode-block" id="TriMesh.find_closest_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.find_closest_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">find_closest_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the count closest nodes to the given node in 2D space.</span>
<span class="sd">            pos = position</span>
<span class="sd">            count = # of nodes to retrieve</span>
<span class="sd">            boundary=1: only choose nodes on the boundary.</span>
<span class="sd">            Copied from TriGrid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">boundary</span><span class="p">:</span>
            <span class="c1"># print &quot;Searching for nearby boundary point&quot;</span>
            <span class="c1"># Rusty&#39;s Note:</span>
            <span class="c1"># This is slow,</span>
            <span class="c1"># but I&#39;m too lazy to add any sort of index specific to</span>
            <span class="c1"># boundary nodes.</span>
            <span class="c1"># Note that this will include interprocessor boundary</span>
            <span class="c1"># nodes, too.</span>
            <span class="n">boundary_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">boundary_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
            <span class="n">closest</span> <span class="o">=</span> <span class="n">boundary_nodes</span><span class="p">[</span><span class="n">order</span><span class="p">[:</span><span class="n">count</span><span class="p">]]</span>
            <span class="c1"># print &quot;   done with boundary node search&quot;</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">closest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">closest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_build_node_index</span><span class="p">()</span>

            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

            <span class="c1"># returns the index of the grid point closest to the given point:</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">],</span> <span class="n">count</span><span class="p">)</span>

            <span class="c1"># newer versions of rtree return a generator:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
                <span class="c1"># so translate that into a list like we used to get.</span>
                <span class="n">hits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hits</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriMesh.shortest_path"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">boundary_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; dijkstra on the edge graph from n1 to n2.</span>
<span class="sd">            copied and modified form Rusty&#39;s code.</span>
<span class="sd">            n1 = node_i for one end of the path</span>
<span class="sd">            n2 = node_i for the other end</span>
<span class="sd">            boundary_only = limit search to edges on the boundary (have</span>
<span class="sd">            a -1 for element2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">priorityDictionary</span><span class="p">()</span>
        <span class="n">queue</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">done</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># find the queue-member with the lowest cost:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">smallest</span><span class="p">()</span>
            <span class="n">best_cost</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">best</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">queue</span><span class="p">[</span><span class="n">best</span><span class="p">]</span>

            <span class="n">done</span><span class="p">[</span><span class="n">best</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_cost</span>

            <span class="k">if</span> <span class="n">best</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                <span class="c1"># print &quot;Found the ending point&quot;</span>
                <span class="k">break</span>

            <span class="c1"># figure out its neighbors</span>
            <span class="n">elems_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">best</span><span class="p">))</span>
            <span class="n">all_nodes_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elems_i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">all_nodes_i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="c1"># both for p and for points that we&#39;ve already done</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">boundary_only</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">((</span><span class="n">best</span><span class="p">,</span> <span class="n">node_i</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BOUNDARY</span><span class="p">:</span>
                        <span class="k">continue</span>


                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> \
                                  <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">best</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">new_cost</span> <span class="o">=</span> <span class="n">best_cost</span> <span class="o">+</span> <span class="n">dist</span>

                <span class="k">if</span> <span class="n">node_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="k">if</span> <span class="n">queue</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">new_cost</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cost</span>

        <span class="c1"># reconstruct the path:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">n2</span><span class="p">]</span>

        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">node_i</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node_i</span> <span class="o">==</span> <span class="n">n1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># figure out its neighbors</span>
            <span class="n">elems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">node_i</span><span class="p">))</span>
            <span class="n">all_nodes_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elems</span><span class="p">])</span>

            <span class="n">found_prev</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">all_nodes_i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nbr</span> <span class="o">==</span> <span class="n">node_i</span> <span class="ow">or</span> <span class="n">nbr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> \
                                  <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">nbr</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="p">)</span>

                <span class="k">if</span> <span class="n">done</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">==</span> <span class="n">done</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
                    <span class="n">found_prev</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found_prev</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_box_from_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Format of the line segment: start_x, start_y, end_x, end_y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">box</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">_find_intersecting_elems_with_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Format of the line segment: start_x, start_y, end_x, end_y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_from_points</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">real_hits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">hit</span><span class="p">][</span><span class="n">i</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> \
                                   <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]))))</span>
            <span class="k">if</span> <span class="n">signs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">signs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signs</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">real_hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">real_hits</span>

<div class="viewcode-block" id="TriMesh.find_elem"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.find_elem">[docs]</a>    <span class="k">def</span> <span class="nf">find_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find a element index from a coordinate</span>
<span class="sd">            pos = A coordinate (2D)</span>
<span class="sd">            return = element index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">])</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">hit</span><span class="p">][</span><span class="n">i</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Test if this is the element (Barycentric method)</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dot00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
            <span class="n">dot01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
            <span class="n">dot02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
            <span class="n">dot11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
            <span class="n">dot12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

            <span class="n">invDenom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot11</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot01</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot11</span> <span class="o">*</span> <span class="n">dot02</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot12</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDenom</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot12</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot02</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDenom</span>

            <span class="c1"># This test returns positive if a dot is on the element border.</span>
            <span class="c1"># And it return anything that is tested first.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">):</span>
                <span class="k">return</span>  <span class="n">hit</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="TriMesh.find_elem_with_tolerance"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.find_elem_with_tolerance">[docs]</a>    <span class="k">def</span> <span class="nf">find_elem_with_tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find a element index from a coordinate with some tolerance</span>
<span class="sd">            pos = A coordinate (2D)</span>
<span class="sd">            return = element index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">])</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">hit</span><span class="p">][</span><span class="n">i</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Test if this is the element (Barycentric method)</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dot00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
            <span class="n">dot01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
            <span class="n">dot02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
            <span class="n">dot11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
            <span class="n">dot12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

            <span class="n">invDenom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot11</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot01</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot11</span> <span class="o">*</span> <span class="n">dot02</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot12</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDenom</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot12</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot02</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDenom</span>

            <span class="c1"># This test returns positive if a dot is on the element border.</span>
            <span class="c1"># And it return anything that is tested first.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tolerance</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tolerance</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">tolerance</span><span class="p">)):</span>
                <span class="k">return</span>  <span class="n">hit</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_build_boundary_node_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">ccw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function builds a node string of boundary nodes from</span>
<span class="sd">            node n1 to n2 in CCW direction.</span>
<span class="sd">            CAVEAT: The node order in the mesh file is assumed CCW.</span>
<span class="sd">            return = array of node_i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_node_on_boundary</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">ccw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No next node on the bouandry...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="n">next_node</span>
        <span class="k">return</span> <span class="n">ns</span>

    <span class="k">def</span> <span class="nf">_clear_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear edge types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">INTERNAL_EDGE</span><span class="p">:</span>
                <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">BOUNDARY_EDGE</span>

    <span class="k">def</span> <span class="nf">_get_next_node_on_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">,</span> <span class="n">ccw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function gets a node index next to the given one</span>
<span class="sd">            on the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">node_i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="n">edges_i</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ccw</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">INTERNAL_EDGE</span><span class="p">)</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">INTERNAL_EDGE</span><span class="p">)</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="TriMesh.find_closest_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.find_closest_elems">[docs]</a>    <span class="k">def</span> <span class="nf">find_closest_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find indices of the closet elems with the given position.</span>
<span class="sd">            The distance is measured with the element mass center.</span>
<span class="sd">            All triangular elems is assumed.</span>
<span class="sd">            pos = position tuple</span>
<span class="sd">            return = element indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">element</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span> <span class="n">center</span><span class="p">)</span>
                <span class="n">center</span> <span class="o">/=</span> <span class="mf">3.</span>
                <span class="n">tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">center</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">Rtree</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">interleaved</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

        <span class="c1"># returns the index of the grid point closest to the given point:</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">],</span> <span class="n">count</span><span class="p">)</span>

        <span class="c1"># newer versions of rtree return a generator:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
            <span class="c1"># so translate that into a list like we used to get.</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hits</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="TriMesh.trim_to_left"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.trim_to_left">[docs]</a>    <span class="k">def</span> <span class="nf">trim_to_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Given a path, trim all elems to the left of it.</span>
<span class="sd">            This fuction is lifted and modified slightly from Rusty&#39;s code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># mark the cut edges:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">INTERNAL_EDGE</span> \
                       <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">CUT_EDGE</span><span class="p">:</span>
                    <span class="c1"># record at least ones that is really cut,</span>
                    <span class="c1"># in case some of the cut edges are</span>
                    <span class="c1"># actually on the boundary</span>
                    <span class="n">cut_edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">CUT_EDGE</span>

        <span class="c1"># choose the first element, based on the last edge that was touched above:</span>

        <span class="c1"># the actual points:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">cut_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">cut_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># the edge index</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">cut_edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># the two elems that form this edge:</span>
        <span class="n">element1</span><span class="p">,</span> <span class="n">element2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
        <span class="n">other_point1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">element1</span><span class="p">],</span> <span class="n">cut_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">other_point2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">element2</span><span class="p">],</span> <span class="n">cut_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">parallel</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="c1"># manually rotate 90deg CCW</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="n">parallel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">parallel</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>


        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">other_point1</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bad</span><span class="p">)</span> \
               <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">other_point2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bad</span><span class="p">):</span>
            <span class="n">bad_elem</span> <span class="o">=</span> <span class="n">element1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bad_elem</span> <span class="o">=</span> <span class="n">element2</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleting elems...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_delete</span><span class="p">(</span><span class="n">bad_elem</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Renumbering nodes and elems...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_renumber</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_recursive_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">renumber</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This fuction is lifted and modified slightly from Rusty&#39;s code.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">del_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="c1"># things the queue have not been processed at all...</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_delete</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># grab somebody:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">to_delete</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># get their edges</span>
            <span class="n">nodea</span><span class="p">,</span> <span class="n">nodeb</span><span class="p">,</span> <span class="n">nodec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

            <span class="n">my_edges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">(</span> <span class="p">(</span><span class="n">nodea</span><span class="p">,</span> <span class="n">nodeb</span><span class="p">)</span> <span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">(</span> <span class="p">(</span><span class="n">nodeb</span><span class="p">,</span> <span class="n">nodec</span><span class="p">)</span> <span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">(</span> <span class="p">(</span><span class="n">nodec</span><span class="p">,</span> <span class="n">nodea</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>

            <span class="c1"># mark it deleted:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># If the first node index is -1, deleted.</span>
            <span class="n">del_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># add their neighbors to the queue to be processed:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">my_edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="c1"># only on non-cut, internal edges:</span>
                    <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">3</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                        <span class="n">nbr</span> <span class="o">=</span> <span class="n">c2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nbr</span> <span class="o">=</span> <span class="n">c1</span>

                    <span class="k">if</span> <span class="n">nbr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleted </span><span class="si">%i</span><span class="s2"> elems.&quot;</span> <span class="o">%</span> <span class="n">del_count</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_renumber</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; removes duplicate elems and nodes that are not</span>
<span class="sd">            referenced by any element,</span>
<span class="sd">            as well as elems that have been deleted (==-1)</span>
<span class="sd">            This fuction is lifted and modified slightly from Rusty&#39;s code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">element_hash</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># sorted tuples of vertices</span>
        <span class="n">new_elems</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of indexes into the old ones</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
            <span class="n">my_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span>

            <span class="k">if</span> <span class="n">my_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">element_hash</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># we&#39;re original and not deleted</span>
                <span class="n">element_hash</span><span class="p">[</span><span class="n">my_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># value is ignored...</span>
                <span class="n">new_elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">new_elems</span><span class="p">]</span> <span class="c1"># Survived elems</span>

        <span class="c1"># remove lonesome nodes</span>
        <span class="n">active_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">active_nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;renumber: Active nodes includes some negative indices&quot;</span><span class="p">)</span>

        <span class="n">old_indices</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">active_nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;renumber: some points have NaNs!&quot;</span><span class="p">)</span>

        <span class="c1"># need a mapping from active node to its index -</span>
        <span class="c1"># explicitly ask for int32 for consistency</span>
        <span class="n">new_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">active_nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">old_indices</span><span class="p">[</span><span class="n">active_nodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_indices</span>
        <span class="c1"># map onto the new indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="n">old_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;renumber: after remapping indices, have negative node index in elems&quot;</span><span class="p">)</span>

        <span class="c1"># clear out stale data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_stale_data</span><span class="p">()</span>

        <span class="c1"># rebuild the edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_edges_from_elems</span><span class="p">()</span>

        <span class="c1"># return the mappings so that subclasses can catch up</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;valid_elems&#39;</span><span class="p">:</span><span class="n">new_elems</span><span class="p">,</span> <span class="s1">&#39;pointmap&#39;</span><span class="p">:</span><span class="n">old_indices</span><span class="p">,</span>
                <span class="s1">&#39;valid_nodes&#39;</span><span class="p">:</span><span class="n">active_nodes</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear up the data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_stale_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_clear_stale_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear up the memory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="TriMesh.is_elem_on_boundary"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.is_elem_on_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">is_elem_on_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check if the given element with index elem_i is on the boundary</span>
<span class="sd">                elem_i = element index</span>
<span class="sd">            return = True if the element is on the boundary, otherwise False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_on_boundary</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element2edges</span><span class="p">(</span><span class="n">elem_i</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INTERNAL_EDGE</span><span class="p">:</span>
                <span class="n">is_on_boundary</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_on_boundary</span></div>

<div class="viewcode-block" id="TriMesh.element2edges"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.element2edges">[docs]</a>    <span class="k">def</span> <span class="nf">element2edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get edge indices from the give element index</span>
<span class="sd">            elem_i = the element index</span>
<span class="sd">            return = generator of found edge indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elem_i</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_edge</span><span class="p">((</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]))</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">edges</span></div>

<div class="viewcode-block" id="TriMesh.build_edgecenters"><a class="viewcode-back" href="../../schimpy.html#schimpy.trimesh.TriMesh.build_edgecenters">[docs]</a>    <span class="k">def</span> <span class="nf">build_edgecenters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build centers of sides</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.array</span>
<span class="sd">                list of side centers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">])</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.trimesh</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, California Department of Water Resources.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>