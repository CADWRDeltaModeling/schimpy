
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>schimpy.triquadmesh &#8212; schimpy 1.4.2+0.g2629342.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo6.png" border="0" alt="Bay-Delta SELFE Tools"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.triquadmesh</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for schimpy.triquadmesh</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is a class to hold an unstructured triangular and quad mesh</span>
<span class="sd">for SCHISM copied and modified</span>
<span class="sd">from Rusty Chris Collerman&#39;s trigrid.</span>

<span class="sd">Prerequisite: Numpy, rtree package, and libspatialindex for rtree</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.priority_queue</span> <span class="kn">import</span> <span class="n">priorityDictionary</span>
<span class="kn">import</span> <span class="nn">rtree</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">types</span>


<div class="viewcode-block" id="enum"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.enum">[docs]</a><span class="k">def</span> <span class="nf">enum</span><span class="p">(</span><span class="o">**</span><span class="n">enums</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A enum type definition</span>

<span class="sd">        Copied from http://stackoverflow.com/questions/36932/how-can-i-represent-an-enum-in-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;Enum&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="n">enums</span><span class="p">)</span></div>


<span class="c1"># Edge trait (or marker)</span>
<span class="c1"># INTERNAL_EDGE = 0</span>
<span class="c1"># BOUNDARY_EDGE = 1</span>
<span class="c1"># OPEN_EDGE = 2</span>
<span class="c1"># LAND_EDGE = 3</span>
<span class="c1"># ISLAND_EDGE = 4</span>
<span class="c1"># CUT_EDGE = 99</span>

<span class="n">EdgeType</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="n">INTERNAL</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">BOUNDARY</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">OPEN</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">LAND</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">ISLAND</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                <span class="n">CUT</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Boundary type</span>
<span class="c1"># INVALID_BOUNDARY = -1</span>
<span class="c1"># OPEN_BOUNDARY = 1</span>
<span class="c1"># LAND_BOUNDARY = 2</span>
<span class="c1"># ISLAND_BOUNDARY = 3</span>

<span class="n">BoundaryType</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="n">INVALID</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">NO_TYPE</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">OPEN</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">LAND</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">ISLAND</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">NodeType</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="n">INVALID</span><span class="o">=-</span><span class="mi">1</span><span class="p">,)</span>

<span class="n">_XXYY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">_X1X2Y1Y2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="n">MAX_NODES</span> <span class="o">=</span> <span class="mi">4</span>


<div class="viewcode-block" id="TriQuadMesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh">[docs]</a><span class="k">class</span> <span class="nc">TriQuadMesh</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class that holds a triangular and quadrilateral mesh information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor of TriQuadMesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Rtree index for nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Rtree index for elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Rtree index for element centers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Node array consisting of three-dimensional coordinates of each node.</span>
<span class="sd">            The shape of the array is (# of nodes, 3)</span>

<span class="sd">            :getter: Get the array of the nodes.</span>
<span class="sd">            :type: Numpy float array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>
    
    <span class="nd">@nodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">newnodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Array of node indexes of all elements.</span>
<span class="sd">            The shape of the array is (# of elems, 5).</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            list of Numpy integer array</span>
<span class="sd">                list of node indexes for all elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="c1"># return self._elems</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the array of edges</span>

<span class="sd">            :getter: Get the array of the edges.</span>
<span class="sd">            :type: Numpy integer array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_edges_from_elems</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node2elems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_elem_balls</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span>

<div class="viewcode-block" id="TriQuadMesh.node"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.node">[docs]</a>    <span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.elem"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.elem">[docs]</a>    <span class="k">def</span> <span class="nf">elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get connectivity of an element</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            elem_i: int</span>
<span class="sd">                element index</span>


<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            Numpy int32 array</span>
<span class="sd">                connectivity of the element (node indexes of the element)</span>
<span class="sd">                None, if the element is marked as deleted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elem_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">INVALID</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elem_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elem_i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">INVALID</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.mark_elem_deleted"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.mark_elem_deleted">[docs]</a>    <span class="k">def</span> <span class="nf">mark_elem_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Mark an element as deleted or invalid.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            elem_i: int</span>
<span class="sd">                element index to mark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">elem_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">INVALID</span></div>

<div class="viewcode-block" id="TriQuadMesh.allocate"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.allocate">[docs]</a>    <span class="k">def</span> <span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_elems</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Allocate memory for nodes and elems</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            n_elems: int</span>
<span class="sd">                Total number of elems</span>
<span class="sd">            n_nodes: int</span>
<span class="sd">                Total number of nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Elements up to 2,147,483,647 (int32)</span>
        <span class="c1"># # of nodes in the element, and connectivities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">MAX_NODES</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TriQuadMesh.set_node"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.set_node">[docs]</a>    <span class="k">def</span> <span class="nf">set_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set one node information.</span>
<span class="sd">            Memory for nodes must be allocated already.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            index: integer</span>
<span class="sd">                Zero-based node index</span>
<span class="sd">            coords: Numpy array</span>
<span class="sd">                a Numpy array of node coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Accessing out of bound in node array&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="TriQuadMesh.set_elem"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.set_elem">[docs]</a>    <span class="k">def</span> <span class="nf">set_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set element connectivity information.</span>
<span class="sd">            Memory for elems must be allocated already.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            index: integer</span>
<span class="sd">                Zero-based element index</span>
<span class="sd">            connectivity: Numpy array</span>
<span class="sd">                a Numpy array of element connectivity, which means node</span>
<span class="sd">                indexes in the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Accessing out of bound in node array&quot;</span><span class="p">)</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_nodes</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough connectivity information.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_nodes</span> <span class="o">&gt;</span> <span class="n">MAX_NODES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many connectivity information.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">connectivity</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TriQuadMesh.n_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.n_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total number of nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.n_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.n_elems">[docs]</a>    <span class="k">def</span> <span class="nf">n_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total number of elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.n_edges"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.n_edges">[docs]</a>    <span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the total number of edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.compare"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compare the mesh with another</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh: triquadmesh.TriQuadMesh</span>
<span class="sd">                a mesh to compare</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            boolean</span>
<span class="sd">                True if they have identical node and element array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_elems</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TriQuadMesh.build_edges_from_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.build_edges_from_elems">[docs]</a>    <span class="k">def</span> <span class="nf">build_edges_from_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build edge array from the elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift:</span>
<span class="sd">            shift of indexing in edged building. It is introduce to keep</span>
<span class="sd">            the ordering of edges in line with SCHISM Mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Building edges from elements&quot;</span><span class="p">)</span>
        <span class="c1"># iterate over elements, and for each element, if it&#39;s index</span>
        <span class="c1"># is smaller than a neighbor or if no neighbor exists,</span>
        <span class="c1"># write an edge record</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this will get built on demand later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
            <span class="c1"># find the neighbors:</span>
            <span class="c1"># the first neighbor: need another element that has</span>
            <span class="c1"># both self._elems[i,0] and self._elems[i,1] in its</span>
            <span class="c1"># list.</span>
            <span class="n">my_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">elem_i</span><span class="p">])</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">n_nodes</span> <span class="o">+</span> <span class="n">shift</span><span class="p">):</span>
                <span class="n">node_a</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="n">j</span> <span class="o">%</span> <span class="n">n_nodes</span><span class="p">]</span>
                <span class="n">node_b</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_nodes</span><span class="p">]</span>
                <span class="n">elem_ball_node_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">node_a</span><span class="p">)</span>
                <span class="n">elem_ball_node_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elems_i_from_node</span><span class="p">(</span><span class="n">node_b</span><span class="p">)</span>

                <span class="c1"># the intersection is us and our neighbor</span>
                <span class="c1"># so difference out ourselves...</span>
                <span class="n">adj_elem_of_edge</span> <span class="o">=</span> <span class="n">elem_ball_node_a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="n">elem_ball_node_b</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">my_set</span><span class="p">)</span>
                <span class="c1"># and maybe we get a neighbor, maybe not (we&#39;re a boundary)</span>
                <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_elem_of_edge</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">adj_elem_i</span> <span class="o">=</span> <span class="n">adj_elem_of_edge</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">n_neighbors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">adj_elem_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot have more than two neighbors &quot;</span>
                                       <span class="s2">&quot;of one edge.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">adj_elem_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">elem_i</span> <span class="o">&lt;</span> <span class="n">adj_elem_i</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node_a</span><span class="p">,</span>
                                  <span class="n">node_b</span><span class="p">,</span>
                                  <span class="n">EdgeType</span><span class="o">.</span><span class="n">BOUNDARY</span>
                                  <span class="k">if</span> <span class="n">adj_elem_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">,</span>
                                  <span class="n">elem_i</span><span class="p">,</span> <span class="n">adj_elem_i</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_build_node_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Building node indexes...&quot;</span><span class="p">)</span>
            <span class="c1"># assemble points into list of (id, [x x y y], None)</span>
            <span class="c1"># but new rtree allows for interleaved coordinates all the time.</span>
            <span class="c1"># best solution probably to specify interleaved=False</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">_XXYY</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())</span>
                      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">Rtree</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">interleaved</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_elem_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Build Rtree index for elems</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Building element indexes...&quot;</span><span class="p">)</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
                <span class="c1"># TODO: This could be better with numpy.</span>
                <span class="n">box</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [xmin xmax ymin ymax]</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">elem_i</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">Rtree</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">interleaved</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="TriQuadMesh.build_elem_balls"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.build_elem_balls">[docs]</a>    <span class="k">def</span> <span class="nf">build_elem_balls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build balls of elements around each node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Remapping nodes to elements...&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Mapping nodes to elements...&quot;</span><span class="p">)</span>
        <span class="c1"># build array for point-&gt;element lookup</span>
        <span class="c1"># Use set for later convenience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())]</span>
        <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node_index</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span></div>

<div class="viewcode-block" id="TriQuadMesh.get_elems_i_from_node"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.get_elems_i_from_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_elems_i_from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the ball of elements around a node, node_i</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            node_i: int</span>
<span class="sd">                node index (zero-based)</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            set</span>
<span class="sd">                set of element indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_elem_balls</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_i</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TriQuadMesh.find_edge"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_edge">[docs]</a>    <span class="k">def</span> <span class="nf">find_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find an edge index with the two given node indexes.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            nodes: array-like</span>
<span class="sd">                two node indexes</span>
<span class="sd">            direction:</span>
<span class="sd">                match the ordering of the nodes when an edge is found.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            int</span>
<span class="sd">                an edge index, None if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">e</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">el1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">el1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">e</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="TriQuadMesh.find_nodes_in_box"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_nodes_in_box">[docs]</a>    <span class="k">def</span> <span class="nf">find_nodes_in_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find nodes in a bounding box. Note that the box is not interleaved.</span>
<span class="sd">        The backend is based on R-tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box: array-like</span>
<span class="sd">            array of bounding box, [x_min, x_max, y_min, y_max]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            node indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_node_index</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

    <span class="k">def</span> <span class="nf">_build_node2edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a map from nodes to edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Building nodes to edges...&quot;</span><span class="p">)</span>
        <span class="c1"># Build node2edges map</span>
        <span class="n">n2e</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())]</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">n2e</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="n">n2e</span>

<div class="viewcode-block" id="TriQuadMesh.get_edges_from_node"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.get_edges_from_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges_from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get edge indexes related to node_i</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            node_i: int</span>
<span class="sd">                Node index (zero-based)</span>
<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            list</span>
<span class="sd">                a list of edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_node2edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="TriQuadMesh.get_neighbor_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.get_neighbor_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbor_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get neighboring node indexes from the given node index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_node2edges</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="TriQuadMesh.add_boundary"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.add_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">add_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">btype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add boundary types to an edge with the given array of node indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_prev_i</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">edge_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">([</span><span class="n">node_prev_i</span><span class="p">,</span> <span class="n">node_i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">edge_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No edge found with the given nodes&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Trying to tag a non-boundary edge &#39;</span>
                                <span class="s1">&#39;as boundary&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">OPEN</span>
            <span class="k">elif</span> <span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">LAND</span> \
                    <span class="ow">or</span> <span class="n">btype</span> <span class="o">==</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">ISLAND</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">LAND</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unsupported boundary type&quot;</span><span class="p">)</span>
            <span class="n">node_prev_i</span> <span class="o">=</span> <span class="n">node_i</span></div>

<div class="viewcode-block" id="TriQuadMesh.find_closest_nodes"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_closest_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">find_closest_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the count closest nodes to the given node in 2D space.</span>
<span class="sd">        Roughly copied from trigrid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pos: array-like</span>
<span class="sd">            position</span>
<span class="sd">        count: int</span>
<span class="sd">            # of nodes to retrieve</span>
<span class="sd">        boundary: int 1</span>
<span class="sd">            only choose nodes on the boundary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or list</span>
<span class="sd">            nearest node indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">boundary</span><span class="p">:</span>
            <span class="c1"># print &quot;Searching for nearby boundary point&quot;</span>
            <span class="c1"># Rusty&#39;s Note:</span>
            <span class="c1"># This is slow,</span>
            <span class="c1"># but I&#39;m too lazy to add any sort of index specific to</span>
            <span class="c1"># boundary nodes.</span>
            <span class="c1"># Note that this will include interprocessor boundary</span>
            <span class="c1"># nodes, too.</span>
            <span class="n">boundary_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">boundary_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
            <span class="n">closest</span> <span class="o">=</span> <span class="n">boundary_nodes</span><span class="p">[</span><span class="n">order</span><span class="p">[:</span><span class="n">count</span><span class="p">]]</span>
            <span class="c1"># print &quot;   done with boundary node search&quot;</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">closest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">closest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_build_node_index</span><span class="p">()</span>

            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

            <span class="c1"># returns the index of the grid point closest to the given point:</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">],</span> <span class="n">count</span><span class="p">)</span>

            <span class="c1"># newer versions of rtree return a generator:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
                <span class="c1"># so translate that into a list like we used to get.</span>
                <span class="n">hits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hits</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.shortest_path"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">boundary_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dijkstra on the edge graph from node n1 to n2.</span>
<span class="sd">        copied and modified form Rusty&#39;s code.</span>
<span class="sd">        Keep in mind that the solution can be non-unique</span>
<span class="sd">        because there are multiple paths that have the same distances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n1: int</span>
<span class="sd">            node index for one end of the path</span>
<span class="sd">        n2: int</span>
<span class="sd">            node_i for the other end</span>
<span class="sd">        boundary_only: boolean</span>
<span class="sd">            limit search to edges on the boundary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            shortest node indexes or None if it cannot be found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">priorityDictionary</span><span class="p">()</span>
        <span class="n">queue</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">done</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># find the queue-member with the lowest cost:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">smallest</span><span class="p">()</span>
            <span class="n">best_cost</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">best</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">queue</span><span class="p">[</span><span class="n">best</span><span class="p">]</span>
            <span class="n">done</span><span class="p">[</span><span class="n">best</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_cost</span>
            <span class="k">if</span> <span class="n">best</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                <span class="c1"># print &quot;Found the ending point&quot;</span>
                <span class="k">break</span>
            <span class="c1"># figure out its neighbors</span>
            <span class="n">all_nodes_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbor_nodes</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">all_nodes_i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="c1"># both for p and for points that we&#39;ve already done</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">boundary_only</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">((</span><span class="n">best</span><span class="p">,</span> <span class="n">node_i</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">BOUNDARY</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">best</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="n">new_cost</span> <span class="o">=</span> <span class="n">best_cost</span> <span class="o">+</span> <span class="n">dist</span>
                <span class="k">if</span> <span class="n">node_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">if</span> <span class="n">queue</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">new_cost</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cost</span>
        <span class="c1"># reconstruct the path:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">n2</span><span class="p">]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">node_i</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node_i</span> <span class="o">==</span> <span class="n">n1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># figure out its neighbors</span>
            <span class="n">all_nodes_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbor_nodes</span><span class="p">(</span><span class="n">node_i</span><span class="p">)</span>
            <span class="n">found_prev</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">all_nodes_i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nbr</span> <span class="o">==</span> <span class="n">node_i</span> <span class="ow">or</span> <span class="n">nbr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">nbr</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">done</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">==</span> <span class="n">done</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
                    <span class="n">found_prev</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">found_prev</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_box_from_points</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format of the line segment: start_x, start_y, end_x, end_y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">box</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,)</span>

<div class="viewcode-block" id="TriQuadMesh.find_intersecting_elems_with_line"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_intersecting_elems_with_line">[docs]</a>    <span class="k">def</span> <span class="nf">find_intersecting_elems_with_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Format of the line segment: start_x, start_y, end_x, end_y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_from_points</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">real_hits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="n">nodes_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">hit</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">nodes_hit</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                
            <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]))))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">signs</span> <span class="o">==</span> <span class="n">signs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">real_hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">real_hits</span></div>

<div class="viewcode-block" id="TriQuadMesh.find_neighbors_on_segment"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_neighbors_on_segment">[docs]</a>    <span class="k">def</span> <span class="nf">find_neighbors_on_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find elements on the line_segment and neighbors that are all to the left (downstream)</span>
<span class="sd">        Format of the line segment: start_x, start_y, end_x, end_y</span>
<span class="sd">        Returns a list of elements on the segment and a list of neighbors. The lists are not guarateed to be ordered spatially</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_from_points</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">box</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No hits for line_segment&quot;</span><span class="p">)</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">neighborset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">real_hits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="n">nodes_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">hit</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
            
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">nodes_hit</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                
            <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> \
                                   <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]))))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">signs</span> <span class="o">==</span> <span class="n">signs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> 
                <span class="c1"># nodes of polygon all on same side of line, no real intersection</span>
                <span class="k">continue</span>
            <span class="n">real_hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>
            <span class="n">candidate_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element2edges</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">candidate_edges</span><span class="p">:</span>
                <span class="c1"># neighbor elemets accepted if their adjoining edges are all on downstream side of </span>
                <span class="c1"># the segment</span>
                <span class="n">edge_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">ee</span><span class="p">]</span>
                <span class="n">nodes_ee</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_info</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>  
                <span class="n">nodes2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">nodes_ee</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                  
                <span class="n">signs2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> \
                                   <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes2</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]))))</span>
                <span class="n">all_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">signs2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">all_left</span><span class="p">:</span>
                    <span class="n">els</span> <span class="o">=</span><span class="n">edge_info</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">els</span><span class="p">:</span> 
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Boundary case not handled&quot;</span><span class="p">)</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">els</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">els</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">hit</span><span class="p">)</span> <span class="k">else</span> <span class="n">els</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">neighborset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                    
        <span class="k">return</span> <span class="n">real_hits</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">neighborset</span><span class="p">)</span></div>




<div class="viewcode-block" id="TriQuadMesh.find_elem"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_elem">[docs]</a>    <span class="k">def</span> <span class="nf">find_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find a element index from a coordinate</span>
<span class="sd">            pos = A coordinate (2D)</span>
<span class="sd">            return = element index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_elem_index</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">])</span>
        <span class="c1"># Test which one is actually intersect</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">nodes</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># Test if this is the element (Barycentric method)</span>
                <span class="n">v0</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dot00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
                <span class="n">dot01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                <span class="n">dot02</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
                <span class="n">dot11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                <span class="n">dot12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

                <span class="n">invDenom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot11</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot01</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot11</span> <span class="o">*</span> <span class="n">dot02</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot12</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDenom</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot00</span> <span class="o">*</span> <span class="n">dot12</span> <span class="o">-</span> <span class="n">dot01</span> <span class="o">*</span> <span class="n">dot02</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDenom</span>

                <span class="c1"># This test returns positive if a dot is on the element border.</span>
                <span class="c1"># And it return anything that is tested first.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">hit</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_build_boundary_node_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">ccw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function builds a node string of boundary nodes from</span>
<span class="sd">            node n1 to n2 in CCW direction.</span>
<span class="sd">            CAVEAT: The node order in the mesh file is assumed CCW.</span>
<span class="sd">            return = array of node_i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_node_on_boundary</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">ccw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No next node on the bouandry...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="n">next_node</span>
        <span class="k">return</span> <span class="n">ns</span>

    <span class="k">def</span> <span class="nf">_clear_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear edge types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span>
                    <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">BOUNDARY</span>

    <span class="k">def</span> <span class="nf">_get_next_node_on_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_i</span><span class="p">,</span> <span class="n">ccw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function gets a node index next to the given one</span>
<span class="sd">            on the boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges_from_node</span><span class="p">(</span><span class="n">node_i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="n">edges_i</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ccw</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">)</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">)</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="TriQuadMesh.find_closest_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.find_closest_elems">[docs]</a>    <span class="k">def</span> <span class="nf">find_closest_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find indexes of the closet elems with the given position.</span>
<span class="sd">            The distance is measured with the element mass center.</span>
<span class="sd">            All triangular elems is assumed.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            pos: array-like</span>
<span class="sd">                2D position</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            int or list</span>
<span class="sd">                element index or indexes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span> <span class="n">center</span><span class="p">)</span>
                <span class="n">center</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
                <span class="n">tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elem_i</span><span class="p">,</span> <span class="n">center</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span> <span class="o">=</span> <span class="n">rtree</span><span class="o">.</span><span class="n">Rtree</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">interleaved</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="c1"># returns the index of the grid point closest to the given point:</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elemcenter_index</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">_XXYY</span><span class="p">],</span> <span class="n">count</span><span class="p">)</span>

        <span class="c1"># newer versions of rtree return a generator:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
            <span class="c1"># so translate that into a list like we used to get.</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hits</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriQuadMesh.trim_elems"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.trim_elems">[docs]</a>    <span class="k">def</span> <span class="nf">trim_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a path, trim all elems to the left of it.</span>
<span class="sd">        This function is lifted and modified slightly from Rusty&#39;s code.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        paths: array of integer array-like</span>
<span class="sd">            arrays of cut paths in arrays of node indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># mark the cut edges:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span>
                    <span class="c1"># or self._edges[e, 2] == EdgeType.CUT:</span>
                    <span class="c1"># record at least ones that is really cut,</span>
                    <span class="c1"># in case some of the cut edges are</span>
                    <span class="c1"># actually on the boundary</span>
                    <span class="n">cut_edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">CUT</span>

        <span class="c1"># choose the first element based on the last edge that was touched</span>
        <span class="c1"># above</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">cut_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">cut_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># the edge index</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">cut_edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># the two elems that form this edge:</span>
        <span class="n">elem1_i</span><span class="p">,</span> <span class="n">elem2_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
        <span class="n">other_point1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem1_i</span><span class="p">),</span> <span class="n">cut_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">other_point2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem2_i</span><span class="p">),</span> <span class="n">cut_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">parallel</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="c1"># manually rotate 90deg CCW</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">parallel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">parallel</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">left</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">other_point1</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bad</span><span class="p">)</span> \
                <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">other_point2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bad</span><span class="p">):</span>
            <span class="n">bad_elem</span> <span class="o">=</span> <span class="n">elem1_i</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">elem2_i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bad_elem</span> <span class="o">=</span> <span class="n">elem2_i</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">elem1_i</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Deleting elems...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_delete</span><span class="p">(</span><span class="n">bad_elem</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Renumbering nodes and elems...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renumber</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_recursive_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i_to_delete</span><span class="p">,</span> <span class="n">renumber</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete elements recursively</span>
<span class="sd">        This function is modified from Rusty&#39;s original function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elem_i_to_delete: int</span>
<span class="sd">            element index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">del_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem_i_to_delete</span><span class="p">]</span>

        <span class="c1"># things the queue have not been processed at all...</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_delete</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># grab somebody:</span>
            <span class="n">elem_i</span> <span class="o">=</span> <span class="n">to_delete</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">conn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

            <span class="c1"># get their edges</span>
            <span class="n">my_edges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">((</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">conn</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_nodes</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)]</span>
            <span class="c1"># mark it deleted:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mark_elem_deleted</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
            <span class="n">del_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># add their neighbors to the queue to be processed:</span>
            <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="n">my_edges</span><span class="p">:</span>
                <span class="c1"># only on non-cut, internal edges:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span>
                    <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">elem_i</span><span class="p">:</span>
                        <span class="n">nbr</span> <span class="o">=</span> <span class="n">c2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nbr</span> <span class="o">=</span> <span class="n">c1</span>

                    <span class="k">if</span> <span class="n">nbr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Deleted </span><span class="si">%i</span><span class="s2"> elems.&quot;</span> <span class="o">%</span> <span class="n">del_count</span><span class="p">)</span>

<div class="viewcode-block" id="TriQuadMesh.renumber"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.renumber">[docs]</a>    <span class="k">def</span> <span class="nf">renumber</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        removes duplicate elems and nodes that are not referenced</span>
<span class="sd">        by any element, as well as elems that have been deleted (==-1)</span>
<span class="sd">        This function is lifted and modified slightly from Rusty&#39;s code.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            {&#39;valid_elems&#39;:new_elems, &#39;pointmap&#39;:old_indexes,</span>
<span class="sd">             &#39;valid_nodes&#39;:active_nodes}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">element_hash</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># sorted tuples of vertices</span>
        <span class="n">new_elems</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of indexes into the old ones</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
            <span class="n">my_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">my_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">element_hash</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># we&#39;re original and not deleted</span>
                <span class="n">element_hash</span><span class="p">[</span><span class="n">my_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># value is ignored...</span>
                <span class="n">new_elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">new_elems</span><span class="p">]</span>  <span class="c1"># Survived elems</span>

        <span class="c1"># remove lonesome nodes</span>
        <span class="n">active_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[:,</span> <span class="p">:</span><span class="n">MAX_NODES</span><span class="p">]))[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">active_nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;renumber: Active nodes includes some negative indexes.&quot;</span><span class="p">)</span>

        <span class="n">old_indexes</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">active_nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;renumber: some points have NaNs!&quot;</span><span class="p">)</span>

        <span class="c1"># need a mapping from active node to its index -</span>
        <span class="c1"># explicitly ask for int32 for consistency</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">active_nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">old_indexes</span><span class="p">[</span><span class="n">active_nodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_indexes</span>
        <span class="c1"># map onto the new indexes</span>
        <span class="n">flag_active_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[:,</span> <span class="p">:</span><span class="n">MAX_NODES</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">flag_active_nodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_indexes</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">[</span><span class="n">flag_active_nodes</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elems</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;renumber: after remapping indexes, have negative node index in elems&quot;</span><span class="p">)</span>

        <span class="c1"># clear out stale data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_stale_data</span><span class="p">()</span>

        <span class="c1"># rebuild the edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_edges_from_elems</span><span class="p">()</span>

        <span class="c1"># return the mappings so that subclasses can catch up</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;valid_elems&#39;</span><span class="p">:</span> <span class="n">new_elems</span><span class="p">,</span> <span class="s1">&#39;pointmap&#39;</span><span class="p">:</span> <span class="n">old_indexes</span><span class="p">,</span>
                <span class="s1">&#39;valid_nodes&#39;</span><span class="p">:</span> <span class="n">active_nodes</span><span class="p">}</span></div>

    <span class="k">def</span> <span class="nf">_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear up the data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_stale_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_clear_stale_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear up the memory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2elems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node2edges</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="TriQuadMesh.is_elem_on_boundary"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.is_elem_on_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">is_elem_on_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check if the given element with index elem_i is on the boundary</span>
<span class="sd">                elem_i = element index</span>
<span class="sd">            return = True if the element is on the boundary, otherwise False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_on_boundary</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">edge_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element2edges</span><span class="p">(</span><span class="n">elem_i</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge_i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span>
                <span class="n">is_on_boundary</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_on_boundary</span></div>

<div class="viewcode-block" id="TriQuadMesh.element2edges"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.element2edges">[docs]</a>    <span class="k">def</span> <span class="nf">element2edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get edge indexes of the give element index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elem_i: int</span>
<span class="sd">            the element index</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of int</span>
<span class="sd">            edge indexes of the element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_edge</span><span class="p">((</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">elem</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_nodes</span><span class="p">]))</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">edges</span></div>

<div class="viewcode-block" id="TriQuadMesh.build_edgecenters"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_mesh.TriQuadMesh.build_edgecenters">[docs]</a>    <span class="k">def</span> <span class="nf">build_edgecenters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build centers of sides</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.array</span>
<span class="sd">                list of side centers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">])</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.triquadmesh</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, California Department of Water Resources.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>