
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>schimpy.schism_setup &#8212; schimpy 1.3.6+7.g9f86f0f.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo6.png" border="0" alt="Bay-Delta SELFE Tools"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.schism_setup</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for schimpy.schism_setup</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Setup and processes SCHISM Inputs</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">.base_io</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.schism_polygon</span> <span class="kn">import</span> <span class="n">SchismPolygon</span><span class="p">,</span> <span class="n">Point</span>
<span class="kn">from</span> <span class="nn">.schism_structure</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.schism_source</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.schism_input</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.schism_mesh</span> <span class="kn">import</span> <span class="n">SchismMesh</span><span class="p">,</span> <span class="n">read_mesh</span><span class="p">,</span> <span class="n">write_mesh</span><span class="p">,</span> <span class="n">BoundaryType</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">osgeo.ogr</span>
<span class="kn">import</span> <span class="nn">osgeo.osr</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">difflib</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">transform</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">pyproj</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">importlib</span>


<div class="viewcode-block" id="SchismSetup"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup">[docs]</a><span class="k">class</span> <span class="nc">SchismSetup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manage SCHISM input data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">=</span> <span class="n">SchismInput</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Mesh</span>

<span class="sd">            :getter: Return the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span>

    <span class="nd">@mesh</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Mesh setter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="SchismSetup.load"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read SCHISM input</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            dir: String</span>
<span class="sd">                An directory where the SCHISM inputs reside</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assuming we are dealing SCHISM format</span>
        <span class="c1"># Read the grid</span>
        <span class="n">gr3_reader</span> <span class="o">=</span> <span class="n">Gr3IO</span><span class="p">()</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;hgrid.gr3&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Grid file not found!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">gr3_reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c1"># Read hydraulics if exists</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;hydraulics.in&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="n">structure_reader</span> <span class="o">=</span> <span class="n">SchismStructureIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="p">)</span>
            <span class="n">structure_reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="c1"># Read source if exists</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;source_sink.in&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="n">source_reader</span> <span class="o">=</span> <span class="n">SchismSourceIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="p">)</span>
            <span class="n">source_reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.get_closest_node_i_from_new_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.get_closest_node_i_from_new_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_closest_node_i_from_new_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">node_i</span><span class="p">):</span>
        <span class="n">old_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">,</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">find_closest_nodes</span><span class="p">(</span><span class="n">old_node</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.adopt_new_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.adopt_new_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">adopt_new_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adopt a new grid.</span>
<span class="sd">                fname = the file name of a new hgrid file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gr3_reader</span> <span class="o">=</span> <span class="n">Gr3IO</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The given mesh file is not found&quot;</span><span class="p">)</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">gr3_reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span>
        <span class="c1"># Boundary build</span>
        <span class="c1"># First delete boundary information of the new mesh</span>
        <span class="n">new_mesh</span><span class="o">.</span><span class="n">clear_boundary</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_boundaries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No boundary is in the original mesh.&quot;</span><span class="p">)</span>
        <span class="c1"># Open boundary</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="p">:</span>
            <span class="c1"># First Node</span>
            <span class="n">node_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_node_i_from_new_mesh</span><span class="p">(</span>
                <span class="n">new_mesh</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># End Node</span>
            <span class="n">node_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_node_i_from_new_mesh</span><span class="p">(</span>
                <span class="n">new_mesh</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Get a path between the two</span>
            <span class="n">new_nodes</span> <span class="o">=</span> <span class="n">new_mesh</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">,</span> <span class="n">boundary_only</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">new_mesh</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">btype</span><span class="p">)</span>

        <span class="c1"># Structure adoption</span>
        <span class="n">new_structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">struct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">structures</span><span class="p">:</span>
            <span class="c1"># Ref node</span>
            <span class="n">new_ref_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_closest_node_i_from_new_mesh</span><span class="p">(</span>
                <span class="n">new_mesh</span><span class="p">,</span> <span class="n">node_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">reference_pair</span><span class="p">)</span>

            <span class="c1"># Node pairs.  This one is slightly trickier</span>
            <span class="n">original_up</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">node_pairs</span><span class="p">]</span>
            <span class="n">original_down</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">node_pairs</span><span class="p">]</span>
            <span class="c1"># Step 1: Create a new path of the upstream side</span>
            <span class="n">node_prev</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_up</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">original_up</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node_prev</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_mesh</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">node_prev</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">new_up</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_up</span> <span class="o">=</span> <span class="n">path</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">new_up</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">new_up</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Path segment does not match.&#39;</span><span class="p">)</span>
                    <span class="n">node_prev</span> <span class="o">=</span> <span class="n">node</span>
            <span class="c1"># Step 2: Create a new downstream node pair</span>
            <span class="n">new_down_inter</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_up</span><span class="p">)):</span>
                <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_mesh</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">original_up</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="n">original_down</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">new_down_inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Step 3: Build middle nodes of the downstream side</span>
            <span class="n">node_prev</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_down</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_down_inter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node_prev</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_mesh</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">node_prev</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">new_down</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_down</span> <span class="o">=</span> <span class="n">path</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">new_down</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">new_down</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Path segment does not match.&#39;</span><span class="p">)</span>
                    <span class="n">node_prev</span> <span class="o">=</span> <span class="n">node</span>
            <span class="c1"># Step 4: Check the pairs</span>
            <span class="n">new_pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_up</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_down</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Number of pairs does not match&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_up</span><span class="p">)):</span>
                <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_mesh</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">new_up</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_down</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Having trouble with &#39;</span><span class="p">)</span>
                <span class="n">new_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_up</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_down</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="c1"># Create a new structure</span>
            <span class="n">struct_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
            <span class="n">struct_new</span><span class="o">.</span><span class="n">reference_pair</span> <span class="o">=</span> <span class="n">new_ref_pair</span>
            <span class="n">struct_new</span><span class="o">.</span><span class="n">node_pairs</span> <span class="o">=</span> <span class="n">new_pairs</span>
            <span class="n">new_structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_new</span><span class="p">)</span>

        <span class="c1"># Source/sink adoption</span>
        <span class="c1"># TODO: This is tricky... I&#39;ll think more about this</span>

        <span class="c1"># Set the new mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">new_mesh</span>
        <span class="c1"># Set new structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structures</span> <span class="o">=</span> <span class="n">new_structures</span></div>

<div class="viewcode-block" id="SchismSetup.write_hgrid"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.write_hgrid">[docs]</a>    <span class="k">def</span> <span class="nf">write_hgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a hgrid file only.</span>
<span class="sd">            fname = the output file name</span>
<span class="sd">            attr = attribute array in numpy format. If None, original data</span>
<span class="sd">            will be kept.</span>
<span class="sd">            boundary = If True, boundary info will be appended at the end of</span>
<span class="sd">            the file. Otherwise, not appended.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">schism_mesh</span><span class="o">.</span><span class="n">write_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.write_hgrid_ll"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.write_hgrid_ll">[docs]</a>    <span class="k">def</span> <span class="nf">write_hgrid_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">input_epsg</span><span class="o">=</span><span class="mi">26910</span><span class="p">,</span> <span class="n">output_epsg</span><span class="o">=</span><span class="mi">4269</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a hgrid.ll, lat-long mesh file, of the current mesh.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            fname: str</span>
<span class="sd">                the output file name</span>
<span class="sd">            input_epsg: int, optional</span>
<span class="sd">                input EPSG. default value is 26910, NAD83/UTM10N.</span>
<span class="sd">            output_epsg: int, optional</span>
<span class="sd">                output EPSG. default value is 4269, NAD83</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">inSpatialRef</span> <span class="o">=</span> <span class="s1">&#39;epsg:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_epsg</span><span class="p">)</span>
        <span class="n">outSpatialRef</span> <span class="o">=</span> <span class="s1">&#39;epsg:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_epsg</span><span class="p">)</span>
        <span class="n">proj_in</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="n">inSpatialRef</span><span class="p">)</span>
        <span class="n">proj_out</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="n">outSpatialRef</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># More performant for pyproj &gt; 2.1.0</span>
            <span class="n">project</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Transformer</span><span class="o">.</span><span class="n">from_proj</span><span class="p">(</span><span class="n">proj_in</span><span class="p">,</span> <span class="n">proj_out</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># In case that isn&#39;t available in earlier versions</span>
            <span class="c1"># but orders of magnitude slow for pyproj 2.1.0</span>
            <span class="n">project</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pyproj</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">proj_in</span><span class="p">,</span> <span class="n">proj_out</span><span class="p">)</span>

        <span class="c1">#new_mesh = SchismMesh()</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">new_mesh</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new_mesh</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
        <span class="c1">#new_mesh._elems = np.copy(self.mesh._elems)</span>

        <span class="c1">#new_mesh = SchismMesh()</span>
        <span class="c1">#new_mesh._nodes = np.copy(self.mesh.nodes)</span>
        <span class="c1">#new_mesh._elems = np.copy(self.mesh._elems)</span>
        <span class="c1">#new_mesh._nodes = transform(project,self.mesh.nodes[:,0],self.mesh.nodes[:,1])</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
            <span class="n">new_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">write_mesh</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span><span class="n">write_boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">)</span></div>


<div class="viewcode-block" id="SchismSetup.elements_on_linestring"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.elements_on_linestring">[docs]</a>    <span class="k">def</span> <span class="nf">elements_on_linestring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List elements along linestring&quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">line_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">find_intersecting_elems_with_line</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.create_flux_regions"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.create_flux_regions">[docs]</a>    <span class="k">def</span> <span class="nf">create_flux_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linestrings</span><span class="p">,</span> <span class="n">out_fname</span><span class="o">=</span><span class="s1">&#39;fluxflag.prop&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and write flux_regions.gr3 with the given lines</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            linestrings: list</span>
<span class="sd">                A list containing information for flux regions.</span>
<span class="sd">                It must contains &#39;linestrings.&#39;</span>
<span class="sd">            out_fname: str, optional</span>
<span class="sd">                Output file name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">flagval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">(),</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>        
        <span class="k">for</span> <span class="n">flagval</span><span class="p">,</span><span class="n">linestring</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">linestrings</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">)</span>
            <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">line_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">ip</span><span class="p">:</span><span class="n">ip</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span> 
                    <span class="n">on_line</span><span class="p">,</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">find_neighbors_on_segment</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Neighbor set not found for linestring </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>               
                <span class="n">flags</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">on_line</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">flagval</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">flags</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">flagval</span> 
                <span class="n">assigned</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">on_line</span> <span class="o">+</span> <span class="n">neighbors</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">elementflags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">out_fname</span><span class="p">,</span> <span class="n">elementflags</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_area_of_poligon</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate area of a polygon based on shoelace formula</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            x: numpy.array</span>
<span class="sd">                array of coordinates for the polygon</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                area of the polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">fabs</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="mf">.5</span>

    <span class="k">def</span> <span class="nf">_clip</span><span class="p">(</span><span class="n">subjectPolygon</span><span class="p">,</span> <span class="n">clipPolygon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  Sutherland-Hodgman polygon clipping algorithm</span>
<span class="sd">             from Rosetta code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span><span class="p">(</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">computeIntersection</span><span class="p">():</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n3</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">n1</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">n3</span><span class="p">,</span> <span class="p">(</span><span class="n">n1</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">n3</span><span class="p">]</span>

        <span class="n">outputList</span> <span class="o">=</span> <span class="n">subjectPolygon</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">clipPolygon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">clipVertex</span> <span class="ow">in</span> <span class="n">clipPolygon</span><span class="p">:</span>
            <span class="n">cp2</span> <span class="o">=</span> <span class="n">clipVertex</span>
            <span class="n">inputList</span> <span class="o">=</span> <span class="n">outputList</span>
            <span class="n">outputList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">inputList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">subjectVertex</span> <span class="ow">in</span> <span class="n">inputList</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">subjectVertex</span>
                <span class="k">if</span> <span class="n">inside</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">inside</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="n">outputList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">computeIntersection</span><span class="p">())</span>
                    <span class="n">outputList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">inside</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">outputList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">computeIntersection</span><span class="p">())</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">cp1</span> <span class="o">=</span> <span class="n">cp2</span>
        <span class="k">return</span><span class="p">(</span><span class="n">outputList</span><span class="p">)</span>

<div class="viewcode-block" id="SchismSetup.creart_sources_from_user_input"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.creart_sources_from_user_input">[docs]</a>    <span class="k">def</span> <span class="nf">creart_sources_from_user_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a source from a user input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read a user input</span>
        <span class="n">source_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_source_user_input</span><span class="p">()</span>
        <span class="n">source_th_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_source_th_user_input</span><span class="p">()</span>
        <span class="n">out_fname</span> <span class="o">=</span> <span class="s1">&#39;source_sink.in&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_source_file</span><span class="p">(</span><span class="n">source_inputs</span><span class="p">,</span> <span class="n">out_fname</span><span class="p">)</span>
        <span class="n">out_fname</span> <span class="o">=</span> <span class="s1">&#39;vsource.th&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_volume_source_history_file</span><span class="p">(</span><span class="n">out_fname</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_read_source_user_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;source_sink.user&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a user input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;the file is corrupted.&#39;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;SOURCE&quot;</span><span class="p">:</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;SINK&quot;</span><span class="p">:</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;the file is corrupted.&#39;</span><span class="p">)</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">inputs</span>

    <span class="k">def</span> <span class="nf">_read_source_th_user_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;source_sink_th.user&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read in a user input for time history of source/sink</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_source_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;source_sink.in&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a source/sink file with the give user input data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="c1"># Count the number of source/sink</span>
        <span class="n">n_sources</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="n">n_sinks</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="c1"># Sources</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">   ! total # of elements with sources</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n_sources</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">element_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_elem</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">  ! </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element_i</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="c1"># Sink</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">   ! total # of elements with sinks</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n_sinks</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">element_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_elem</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">  ! </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element_i</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_volume_source_history_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;msource.th&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a time history file of sources/sinks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="SchismSetup.create_structures"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.create_structures">[docs]</a>    <span class="k">def</span> <span class="nf">create_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">,</span> <span class="n">nudging</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create structures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">clear_structures</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">_nudging</span> <span class="o">=</span> <span class="n">nudging</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">structures</span><span class="p">:</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">SchismStructure</span><span class="p">()</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Processing structure: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">end_points</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;end_points&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No end_points in structure&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end_points</span><span class="p">)</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;configuration&#39;</span><span class="p">]</span>

            <span class="c1"># Find node pairs</span>
            <span class="n">up_path</span><span class="p">,</span> <span class="n">down_path</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_two_neighboring_node_paths</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">node_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">up_path</span><span class="p">,</span> <span class="n">down_path</span><span class="p">))</span>
            <span class="c1"># Reference pair</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reference&#39;</span><span class="p">,</span> <span class="s1">&#39;self&#39;</span><span class="p">)</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="o">==</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">reference_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_reference_pair</span><span class="p">(</span><span class="n">up_path</span><span class="p">,</span>
                                                                      <span class="n">down_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">reference_pair</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">add_structure</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">struct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">structures</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">struct</span><span class="o">.</span><span class="n">reference_pair</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structures</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">struct</span><span class="o">.</span><span class="n">reference</span> <span class="o">==</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">reference_pair</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reference_pair</span><span class="p">)</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">found</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Reference name not found: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                       <span class="n">item</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong reference name in structures&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.write_structures"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.write_structures">[docs]</a>    <span class="k">def</span> <span class="nf">write_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s2">&quot;hydraulics.in&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write a SCHISM structure file</span>
<span class="sd">            fname = output file name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">struct_writer</span> <span class="o">=</span> <span class="n">SchismStructureIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="p">)</span>
        <span class="n">struct_writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_generate_reference_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">up_path</span><span class="p">,</span> <span class="n">down_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate a new referece pair from the current node pairs.</span>
<span class="sd">            For now, it picks the neighboring nodes around the</span>
<span class="sd">            middle node pair.</span>
<span class="sd">            node_pairs = the list of node pairs</span>
<span class="sd">            return = the new reference pair</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_reference_node</span><span class="p">(</span><span class="n">up_path</span><span class="p">,</span> <span class="n">down_path</span><span class="p">)</span>
        <span class="n">ref_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_reference_node</span><span class="p">(</span><span class="n">down_path</span><span class="p">,</span> <span class="n">up_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ref_up</span><span class="p">,</span> <span class="n">ref_down</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_reference_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">):</span>
        <span class="c1"># TODO: The safety of this code needs to check further</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="c1"># path1</span>
        <span class="n">center_node_i</span> <span class="o">=</span> <span class="n">path1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_neighbor_nodes</span><span class="p">(</span><span class="n">center_node_i</span><span class="p">)</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">path1</span> <span class="ow">or</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">path2</span><span class="p">):</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No reference node founde&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If there are multiple candidates, a most perpendicular one</span>
            <span class="c1"># to the line constructed by the two end points of the path1</span>
            <span class="c1"># is chosen.</span>
            <span class="n">tangent</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">path1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">path1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">tangent</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">c</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">center_node_i</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">vec</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">tangent</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
                    <span class="nb">min</span> <span class="o">=</span> <span class="n">dot</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">return</span> <span class="n">hit</span>

    <span class="k">def</span> <span class="nf">_parse_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse expression that can be understood by the tool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\b)x(\b)&quot;</span><span class="p">,</span> <span class="s2">&quot;\g&lt;1&gt;mesh.nodes[nodes_sel, 0]\g&lt;2&gt;&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\b)y(\b)&quot;</span><span class="p">,</span> <span class="s2">&quot;\g&lt;1&gt;mesh.nodes[nodes_sel, 1]\g&lt;2&gt;&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\b)z(\b)&quot;</span><span class="p">,</span> <span class="s2">&quot;\g&lt;1&gt;mesh.nodes[nodes_sel, 2]\g&lt;2&gt;&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\b)min(\b)&quot;</span><span class="p">,</span> <span class="s2">&quot;\g&lt;1&gt;numpy.minimum\g&lt;2&gt;&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\b)max(\b)&quot;</span><span class="p">,</span> <span class="s2">&quot;\g&lt;1&gt;numpy.maximum\g&lt;2&gt;&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

<div class="viewcode-block" id="SchismSetup.apply_linestring_ops"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.apply_linestring_ops">[docs]</a>    <span class="k">def</span> <span class="nf">apply_linestring_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">default</span><span class="p">,</span><span class="n">linestrings</span><span class="p">):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>             
        <span class="n">attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">istring</span><span class="p">,</span><span class="n">linestring</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">linestrings</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="n">widen_left</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;widen_left&#39;</span><span class="p">)</span>
            <span class="n">widen</span><span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">widen_left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">widen_left</span>
             
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">)</span>
            <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">attribute</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attribute&quot;</span><span class="p">)</span>
            <span class="c1">#optype = linestring.get(&quot;type&quot;)</span>
            <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s1">&#39;local_min&#39;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span>
            <span class="k">elif</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s1">&#39;local_max&#39;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
            <span class="k">elif</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s1">&#39;local_mean&#39;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
            <span class="k">elif</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s1">&#39;local_median&#39;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">opval</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">opval</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linestring attribute was not a known value (e.g. local_min, local_med) or a float&quot;</span><span class="p">)</span>
                     
            
            <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoint</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>   <span class="c1"># loop through segments on linestring</span>
                <span class="n">line_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">ip</span><span class="p">:</span><span class="n">ip</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span> 
                    <span class="n">on_line</span><span class="p">,</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">find_neighbors_on_segment</span><span class="p">(</span><span class="n">line_segment</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">widen</span><span class="p">:</span>
                        <span class="n">on_line</span> <span class="o">=</span> <span class="n">on_line</span> <span class="o">+</span> <span class="n">neighbors</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Elements or neighbors not found for linestring </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>  
                
  
                <span class="n">node_local_nds</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">iel</span> <span class="ow">in</span> <span class="n">on_line</span><span class="p">:</span>
                    <span class="n">elnodes</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">iel</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">elnodes</span><span class="p">:</span>
                        <span class="c1"># list all the nodes on the element as being local to one another</span>
                        <span class="c1"># ultimately this list will include items pertinent to each node from</span>
                        <span class="c1"># multiple elements</span>
                        <span class="k">if</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">node_local_nds</span><span class="p">:</span>
                            <span class="n">node_local_nds</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">elnodes</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> 
                            <span class="n">node_local_nds</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">elnodes</span><span class="p">)</span>


                <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">node_local_nds</span><span class="p">:</span>
                    <span class="n">support_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_local_nds</span><span class="p">[</span><span class="n">inode</span><span class="p">])</span>
                    <span class="n">orig</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">support_nodes</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">valreplace</span><span class="o">=</span><span class="n">op</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span>
                    <span class="n">attr</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span><span class="o">=</span><span class="n">valreplace</span>
        <span class="k">return</span> <span class="n">attr</span></div>


<div class="viewcode-block" id="SchismSetup.apply_polygons"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.apply_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">apply_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Partition the grid with the given polygons.</span>
<span class="sd">            Each node (not element) will be assigned with an integer ID</span>
<span class="sd">            which is the index of the polygons.</span>
<span class="sd">            If some polygons overlap, the latter one will trump the former one.</span>
<span class="sd">            The area that are not covered by any of the given polygons</span>
<span class="sd">            will have a default negative one attribute.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            polygons: list</span>
<span class="sd">                a list of polygon dict (from YAML most of time)</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use depth</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fill default values</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">())</span>
            <span class="n">attr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="n">imports_str</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;imports&#39;</span><span class="p">)</span>
            <span class="n">imports</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;numpy&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imports_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">imports</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">imports_str</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The number of coordinates in vertices are wrong.&#39;</span><span class="p">)</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">poly_type</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> \
                <span class="k">if</span> <span class="s1">&#39;type&#39;</span> <span class="ow">in</span> <span class="n">polygon</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
            <span class="k">if</span> <span class="n">poly_type</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">poly_type</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="n">attribute</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[</span><span class="s1">&#39;attribute&#39;</span><span class="p">]</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">poly_type</span><span class="p">,</span> <span class="s1">&#39;attribute&#39;</span><span class="p">:</span> <span class="n">attribute</span><span class="p">}</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">SchismPolygon</span><span class="p">(</span><span class="n">shell</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span> <span class="n">prop</span><span class="o">=</span><span class="n">prop</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">expr_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">expr_str</span><span class="p">,</span> <span class="s2">&quot;fail.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">attribute</span><span class="p">),</span> <span class="s2">&quot;fail.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">)</span>

            <span class="c1">## Add global variables</span>
            <span class="n">newglobals</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">newglobals</span><span class="p">[</span><span class="s1">&#39;imports&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imports</span>
            <span class="n">newglobals</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="n">newglobals</span><span class="p">[</span><span class="s1">&#39;polygon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span>

            <span class="c1"># Evaluate</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nodes_sel</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_in_polygon</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">newglobals</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Polygon failed to evaluate: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">raise</span>
            <span class="c1"># if 97346 in nodes_sel: </span>
                <span class="c1"># print(poly.type)</span>
                <span class="c1"># print(&quot;Arrived in poly {}&quot;.format(name))</span>
                <span class="c1"># for ii,isel in enumerate(nodes_sel):</span>
                    <span class="c1"># if isel == 97346: </span>
                        <span class="c1"># print(ii,isel,mesh.nodes[isel,:],vals[ii])</span>
                        <span class="c1"># #raise ValueError(&quot;Arrived. Poly type = {}&quot;.format(poly.type))</span>
                     
                

            <span class="k">if</span> <span class="n">nodes_sel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_sel</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;This polygon contains no nodes: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">poly</span><span class="o">.</span><span class="n">name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                    <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
                <span class="k">elif</span> <span class="n">poly</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                    <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vals</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">poly</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                    <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">vals</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="n">nodes_sel</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;Not supported polygon type (</span><span class="si">{}</span><span class="s2">) for polygon (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Error applying formula in polygon: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">raise</span>
        <span class="c1"># TODO: Not implemented debug messaged yet.</span>
        <span class="c1"># n_missed = sum(1 for i, a in enumerate(attr) if a == default)</span>
        <span class="c1"># if n_missed &gt; 0:</span>
        <span class="c1">#     msg = &quot;There are %d nodes that do not belong &quot; \</span>
        <span class="c1">#           &quot;to any polygon.&quot; % n_missed</span>
        <span class="c1">#     self._logger.warning(msg)</span>
        <span class="c1">#     if default is not None:</span>
        <span class="c1">#         msg = &quot;Default value of %.f is used for them.&quot; % default</span>
        <span class="c1">#         self._logger.warning(msg)</span>
        <span class="k">return</span> <span class="n">attr</span></div>

    <span class="k">def</span> <span class="nf">_evaluate_in_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="nb">globals</span><span class="p">):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span>
        <span class="n">imports</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">[</span><span class="s1">&#39;imports&#39;</span><span class="p">]</span>
        <span class="n">mod_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># if imports is not None:</span>
        <span class="k">for</span> <span class="n">imp</span> <span class="ow">in</span> <span class="n">imports</span><span class="p">:</span>
            <span class="n">iname</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># ipack = &#39;.&#39;.join(imp.split(&#39;.&#39;)[0:-1])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if len(ipack) &gt; 0 else importlib.import_module(iname)</span>
                <span class="n">mod</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">imp</span><span class="p">)</span>
                <span class="n">mod_names</span><span class="p">[</span><span class="n">iname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to import </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">imp</span><span class="p">))</span>
        <span class="nb">globals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mod_names</span><span class="p">)</span>

        <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">bounds</span><span class="p">)[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
        <span class="n">node_candidates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">find_nodes_in_box</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="n">nodes_in_polygon</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_i</span> <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">node_candidates</span>
                            <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">]))]</span>
        <span class="nb">globals</span><span class="p">[</span><span class="s1">&#39;nodes_sel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_in_polygon</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">globals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes_in_polygon</span><span class="p">,</span> <span class="n">vals</span>

<div class="viewcode-block" id="SchismSetup.create_node_partitioning"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.create_node_partitioning">[docs]</a>    <span class="k">def</span> <span class="nf">create_node_partitioning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr3_fname</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">smooth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a gr3 file with node partitioning using</span>
<span class="sd">            polygons in the polygon file.</span>
<span class="sd">            gr3_fname = output gr3 file name</span>
<span class="sd">            polygons = polygons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">schimpy.laplace_smooth_data</span> <span class="kn">import</span> <span class="n">laplace_smooth_data2</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_polygons</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Smoothing data. This process can take several minutes&quot;</span><span class="p">)</span>
            <span class="n">attr</span><span class="o">=</span><span class="n">laplace_smooth_data2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span><span class="o">**</span><span class="n">smooth</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gr3_fname</span> <span class="o">!=</span> <span class="s1">&#39;hgrid.gr3&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_hgrid</span><span class="p">(</span><span class="n">gr3_fname</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_hgrid</span><span class="p">(</span><span class="n">gr3_fname</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.create_prop_partitioning"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.create_prop_partitioning">[docs]</a>    <span class="k">def</span> <span class="nf">create_prop_partitioning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop_fname</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a prop file with element partitioning using</span>
<span class="sd">            polygons in the polygon file.</span>
<span class="sd">            prop_fname = output prop file name</span>
<span class="sd">            polygons = polygons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># option_name = &#39;default&#39;</span>
        <span class="c1"># # default = polygon_data[option_name]</span>
        <span class="c1"># polygons = polygon_data[&#39;polygons&#39;]</span>
        <span class="c1"># attr = self._partition_nodes_with_polygons(polygons, default)</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_polygons</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">elementflags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">(),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">elementflags</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">()):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elem</span><span class="p">(</span><span class="n">elem_i</span><span class="p">)</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">attr</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">elementflags</span><span class="p">[</span><span class="n">elem_i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_elems</span><span class="p">(),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">prop_fname</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">elementflags</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.modify_depth"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.modify_depth">[docs]</a>    <span class="k">def</span> <span class="nf">modify_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Modify depth with the polygon information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="n">polygon_data</span><span class="p">[</span><span class="s1">&#39;polygons&#39;</span><span class="p">]</span>
        <span class="c1">#attr = self._partition_nodes_with_polygons(polygons, None)</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_polygons</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span></div>

<div class="viewcode-block" id="SchismSetup.create_source_sink_in"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.create_source_sink_in">[docs]</a>    <span class="k">def</span> <span class="nf">create_source_sink_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_sinks</span><span class="p">,</span> <span class="n">out_fname</span><span class="o">=</span><span class="s1">&#39;source_sink.in&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create source_sink.in from source/sink location information</span>
<span class="sd">            in_fname = input file name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: I need to use a common source/sink I/O routines.</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;sources&#39;</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="n">source_sinks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">source_sinks</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;sinks&#39;</span>
        <span class="n">sinks</span> <span class="o">=</span> <span class="n">source_sinks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">source_sinks</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">fout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> ! total # of elems with sources</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">sources</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">element_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_elem</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">element_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">element_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_closest_elems</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> ! </span><span class="si">%s</span><span class="s2">, nudged</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> ! </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="si">%d</span><span class="s2"> ! total # of elems with sinks</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">sinks</span><span class="p">)</span>
        <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">sinks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">element_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_elem</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">element_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">element_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_closest_elems</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> ! </span><span class="si">%s</span><span class="s2">, nudged</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> ! </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

        <span class="n">fout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="SchismSetup.reorder_open_boundaries"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.reorder_open_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_open_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reorder open boundaries with the given order</span>
<span class="sd">            order = list of open boundary names</span>
<span class="sd">            TODO: How to put the name of the boundaries is not settled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">open_boundaries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">boundary</span> <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">boundaries</span>
                               <span class="k">if</span> <span class="n">boundary</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">OPEN_BOUNDARY</span><span class="p">)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">open_boundaries</span><span class="p">:</span>
            <span class="c1"># extract names from the comments</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">comment</span><span class="p">[</span><span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">p2</span><span class="p">]</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">open_boundaries</span><span class="p">)]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">open_boundaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dt_out</span><span class="p">,</span> <span class="n">out_fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Interpolate tide data.</span>
<span class="sd">            The code is copied and modified from interpolate_elev.py.</span>
<span class="sd">            times = an array of time stamps</span>
<span class="sd">            data = an array of tide data</span>
<span class="sd">            dt_out = delta t for output</span>
<span class="sd">            out_fname = output file name</span>

<span class="sd">            TODO: The code may need to be cleaned up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ntimes</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">etime</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dt_in</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">,</span> <span class="n">dt_out</span><span class="p">)</span>
        <span class="n">nout</span> <span class="o">=</span> <span class="n">new_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Interpolating to a new series of size </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">nout</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># There is a limit on the size of the array for 1d</span>
        <span class="c1"># spline interpolation (interp1d).</span>
        <span class="c1"># Testing on PC indicates it will work up to 2500.</span>
        <span class="c1"># The larger the array, the slower the performance.</span>
        <span class="c1"># We use 1000 in this script.</span>
        <span class="c1"># To minimize edge effect, at 20% on each side.</span>
        <span class="n">max_size_spline</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">add_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">)</span>

        <span class="n">dt_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dt_in</span> <span class="o">/</span> <span class="n">dt_out</span><span class="p">)</span>
        <span class="n">loop_step</span> <span class="o">=</span> <span class="n">max_size_spline</span> <span class="o">*</span> <span class="n">dt_ratio</span>
        <span class="k">if</span> <span class="n">nout</span> <span class="o">%</span> <span class="n">loop_step</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloop</span> <span class="o">=</span> <span class="n">nout</span> <span class="o">//</span> <span class="n">loop_step</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloop</span> <span class="o">=</span> <span class="n">nout</span> <span class="o">//</span> <span class="n">loop_step</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;number of loops required to convert the file: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">iloop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;steps per loop: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">loop_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iloop</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;working on loop </span><span class="si">%s</span><span class="s2"> out of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iloop</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">iin_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iin_start</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">max_size_spline</span> <span class="o">-</span> <span class="n">add_size</span>

            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">iloop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># for the last run of the loop</span>
                <span class="n">iin_end</span> <span class="o">=</span> <span class="n">ntimes</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># set the end to the last input element</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iin_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_size_spline</span> <span class="o">+</span> <span class="n">add_size</span>
                <span class="k">if</span> <span class="n">iin_end</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ntimes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">iin_end</span> <span class="o">=</span> <span class="n">ntimes</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">iout_start</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">loop_step</span>
            <span class="n">iout_end</span> <span class="o">=</span> <span class="n">iout_start</span> <span class="o">+</span> <span class="n">loop_step</span>
            <span class="c1"># to avoid &quot;ValueError:</span>
            <span class="c1"># A value in x_new is above the interpolation range.&quot;</span>
            <span class="c1"># reduce output end time</span>
            <span class="k">if</span> <span class="n">iout_end</span> <span class="o">*</span> <span class="n">dt_out</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">iin_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt_in</span><span class="p">:</span>
                <span class="n">iout_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">iin_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt_ratio</span>

            <span class="n">spline</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">iin_start</span><span class="p">:</span><span class="n">iin_end</span><span class="p">],</span>
                              <span class="n">data</span><span class="p">[</span><span class="n">iin_start</span><span class="p">:</span><span class="n">iin_end</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
            <span class="n">est_times</span> <span class="o">=</span> <span class="n">new_times</span><span class="p">[</span><span class="n">iout_start</span><span class="p">:</span><span class="n">iout_end</span><span class="p">]</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">est_times</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">)):</span>
                <span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">est_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt_out</span><span class="p">,</span> <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_adjust_ocean_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read ocean map</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;ocean.gr3&#39;</span>
        <span class="n">gr3io</span> <span class="o">=</span> <span class="n">Gr3IO</span><span class="p">()</span>
        <span class="n">ocean_mesh</span> <span class="o">=</span> <span class="n">gr3io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="c1"># Read ocean tide harmonics</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;ocean.ap&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_nodes</span> <span class="o">!=</span> <span class="n">ocean_mesh</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Node numbers in the mesh and tide harmonic files&#39;</span>
                            <span class="s1">&#39; are not identical.&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">n_harmonics</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">harmonics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_harmonics</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">harmonic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">tokens</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">harmonic</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">tokens</span><span class="p">))</span>
            <span class="n">harmonics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">harmonic</span>

        <span class="c1"># Calculate weights</span>
        <span class="c1"># Get ocean boundary: Assume the first one is the ocean</span>
        <span class="n">ocean_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">ocean_boundary</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">element_i</span> <span class="o">=</span> <span class="n">ocean_mesh</span><span class="o">.</span><span class="n">find_elem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">][:</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">element_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">element_i</span> <span class="o">=</span> <span class="n">ocean_mesh</span><span class="o">.</span><span class="n">find_elem_with_tolerance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_i</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.1</span><span class="p">)</span>

<div class="viewcode-block" id="SchismSetup.interpolate_tide"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.interpolate_tide">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_tide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_start</span><span class="p">,</span> <span class="n">time_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span>
                         <span class="n">in_fname</span><span class="p">,</span> <span class="n">out_fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Interpolate an observed tide time series with the given dt.</span>
<span class="sd">            time_start = start time in Python datetime</span>
<span class="sd">            time_end = end time in Python datetime</span>
<span class="sd">            dt = delta t for the interpolation output</span>
<span class="sd">            in_fname = input file name of tide records</span>
<span class="sd">            out_fname = output file name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read the tide input</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">in_fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="c1"># ignore first three header lines</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Parse it</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">time_str</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_str</span><span class="p">,</span> <span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y,%H:%M&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">time_start</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">time_end</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">time_start</span>
                <span class="n">delta_in_sec</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">days</span> <span class="o">*</span> <span class="mi">86400</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">seconds</span>
                <span class="n">timestamps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta_in_sec</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Interpolate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">out_fname</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.create_open_boundaries"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.create_open_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">create_open_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create open boundaries with linestrings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">clear_boundaries</span><span class="p">()</span>
        <span class="n">boundary_only</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">linestrings</span> <span class="o">=</span> <span class="n">segments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;linestrings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linestrings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Linestrings is required for open boundaries&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linestrings</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">])</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_closest_nodes</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">boundary_only</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_closest_nodes</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">boundary_only</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">_build_boundary_node_string</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">boundary_only</span><span class="p">)</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;! Open boundary </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_boundary</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">BoundaryType</span><span class="o">.</span><span class="n">OPEN</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span></div>

<div class="viewcode-block" id="SchismSetup.trim_to_left_of_mesh"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.SchismSetup.trim_to_left_of_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">trim_to_left_of_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Trim mesh using line_segments.</span>
<span class="sd">            This function trims the mesh on the left sides</span>
<span class="sd">            of the line segments. The left side here means left when you look</span>
<span class="sd">            at the second end point of a line segment from the first one.</span>
<span class="sd">            An actual path to trimming is a nodal path that is on the</span>
<span class="sd">            right side of the line segment.</span>
<span class="sd">            To manage torus like mesh topology, the argument takes an array</span>
<span class="sd">            of line segments. The user need to provides a set of line segments</span>
<span class="sd">            to make sure the left side of the line segments does not</span>
<span class="sd">            cover the whole mesh.</span>
<span class="sd">            To trim multiple parts of a mesh, use this function</span>
<span class="sd">            multiple times.</span>
<span class="sd">            This function clears up any boundary definitions associated with</span>
<span class="sd">            the original grid. It is user&#39;s responsibility to create them</span>
<span class="sd">            again.</span>

<span class="sd">            line_segments = array of line segments defined by two end points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Trimming the mesh...&quot;</span><span class="p">)</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line_segments</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">find_two_neighboring_paths</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">trim_to_left</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">clear_boundary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removed the old boundary information.&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="load_schism"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.load_schism">[docs]</a><span class="k">def</span> <span class="nf">load_schism</span><span class="p">(</span><span class="nb">dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A load function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">SchismSetup</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="create_schism_setup"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.create_schism_setup">[docs]</a><span class="k">def</span> <span class="nf">create_schism_setup</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read a mesh and return a SCHISM input set-up instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname: str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SCHISM input set-up instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">SchismSetup</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
    <span class="c1"># Read the grid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Grid file not found: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">read_mesh</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="check_similarity"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.check_similarity">[docs]</a><span class="k">def</span> <span class="nf">check_similarity</span><span class="p">(</span><span class="n">testee</span><span class="p">,</span> <span class="n">list_words</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check similarity of a word &quot;&quot;&quot;</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">difflib</span><span class="o">.</span><span class="n">SequenceMatcher</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">list_words</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">reserved</span> <span class="ow">in</span> <span class="n">list_words</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">set_seqs</span><span class="p">(</span><span class="n">testee</span><span class="p">,</span> <span class="n">reserved</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">reserved</span></div>


<div class="viewcode-block" id="check_and_suggest"><a class="viewcode-back" href="../../schimpy.html#schimpy.schism_setup.check_and_suggest">[docs]</a><span class="k">def</span> <span class="nf">check_and_suggest</span><span class="p">(</span><span class="n">testees</span><span class="p">,</span> <span class="n">list_words</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check testtees in list_words and if not suggest something if possible</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">testees</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_words</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unrecognizable key word: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">similar_one</span> <span class="o">=</span> <span class="n">check_similarity</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">list_words</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">similar_one</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;-- Did it mean &#39;</span><span class="si">%s</span><span class="s2">&#39;?&quot;</span> <span class="o">%</span> <span class="n">similar_one</span>
                <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Acceptable items in this section are: &quot;</span> <span class="o">+</span> \
                  <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_words</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognizable item (see log for details): &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">))</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">schimpy.schism_setup</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, California Department of Water Resources.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>